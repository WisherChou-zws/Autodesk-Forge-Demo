/*!
 * LMV v7.1.1
 * 
 * Copyright 2019 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.Pushpins =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/Pushpins/PushPinExtension.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/Pushpins/PushPinConstants.js":
/*!*************************************************!*\
  !*** ./extensions/Pushpins/PushPinConstants.js ***!
  \*************************************************/
/*! exports provided: statusHexValues, moveableIcon, cursorIcon, markerOffsets, thumbnailOriginalPixelSize, thumbnailSize, thumbnailZoom, thumbnailMarkerRadius, ATTRIBUTES_VERSION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "statusHexValues", function() { return statusHexValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moveableIcon", function() { return moveableIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cursorIcon", function() { return cursorIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "markerOffsets", function() { return markerOffsets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "thumbnailOriginalPixelSize", function() { return thumbnailOriginalPixelSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "thumbnailSize", function() { return thumbnailSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "thumbnailZoom", function() { return thumbnailZoom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "thumbnailMarkerRadius", function() { return thumbnailMarkerRadius; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTES_VERSION", function() { return ATTRIBUTES_VERSION; });
var statusHexValues = {
  /* Issues */

  'issues-draft': '#819099',
  'issues-draft-selected': '#819099',
  'issues-draft-movable': '#819099',

  'issues-open': '#ffba0c',
  'issues-open-selected': '#ffba0c',
  'issues-open-movable': '#ffba0c',

  'issues-answered': '#087cd9',
  'issues-answered-selected': '#087cd9',
  'issues-answered-movable': '#087cd9',

  'issues-closed': '#bcc9d1',
  'issues-closed-selected': '#bcc9d1',
  'issues-closed-movable': '#bcc9d1',

  /* RFIs */

  'rfis-draft': '#819099',
  'rfis-draft-selected': '#819099',
  'rfis-draft-movable': '#819099',

  'rfis-submitted': '#7a77d9',
  'rfis-submitted-selected': '#7a77d9',
  'rfis-submitted-movable': '#7a77d9',

  'rfis-open': '#ffba0c',
  'rfis-open-selected': '#ffba0c',
  'rfis-open-movable': '#ffba0c',

  'rfis-answered': '#087cd9',
  'rfis-answered-selected': '#087cd9',
  'rfis-answered-movable': '#087cd9',

  'rfis-rejected': '#ff495c',
  'rfis-rejected-selected': '#ff495c',
  'rfis-rejected-movable': '#ff495c',

  'rfis-closed': '#bcc9d1',
  'rfis-closed-selected': '#bcc9d1',
  'rfis-closed-movable': '#bcc9d1',

  'rfis-void': '#bcc9d1',
  'rfis-void-selected': '#bcc9d1',
  'rfis-void-movable': '#bcc9d1',


  /* Field Issues */

  'quality_issues-draft': '#819099',
  'quality_issues-draft-selected': '#819099',
  'quality_issues-draft-movable': '#819099',

  'quality_issues-not_approved': '#ff495c',
  'quality_issues-not_approved-selected': '#ff495c',
  'quality_issues-not_approved-movable': '#ff495c',

  'quality_issues-open': '#ffba0c',
  'quality_issues-open-selected': '#ffba0c',
  'quality_issues-open-movable': '#ffba0c',

  'quality_issues-ready_to_inspect': '#7a77d9',
  'quality_issues-ready_to_inspect-selected': '#7a77d9',
  'quality_issues-ready_to_inspect-movable': '#7a77d9',

  'quality_issues-void': '#bcc9d1',
  'quality_issues-void-selected': '#bcc9d1',
  'quality_issues-void-movable': '#bcc9d1',

  'quality_issues-work_completed': '#087cd9',
  'quality_issues-work_completed-selected': '#087cd9',
  'quality_issues-work_completed-movable': '#087cd9',

  // "in_dispute" pushpins are the same as "not_approved" ones
  'quality_issues-in_dispute': '#ff495c',
  'quality_issues-in_dispute-selected': '#ff495c',
  'quality_issues-in_dispute-movable': '#ff495c',

  // "closed" pushpins are the same as "void" ones
  'quality_issues-closed': '#bcc9d1',
  'quality_issues-closed-selected': '#bcc9d1',
  'quality_issues-closed-movable': '#bcc9d1',

  'quality_issues-answered': '#087cd9',
  'quality_issues-answered-selected': '#087cd9',
  'quality_issues-answered-movable': '#087cd9' };


var moveableIcon = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEsAAABMCAYAAAAlS0pSAAAA4UlEQVR42u3bSw7DIAwFwNz/zhXddNVuoPWHlHkHCGKUgG0p1yVyTMYrJGDFQwFbhAIGKw8KGKw8KGCLUMBg5UEdDQYrGeo4sBEUWLC0O7BgwYIFCxYsWLBgwYL1r1jRm8nGasPP3Ew2VhlY1Waqnl96ntwdKxytagjXifXzOtUTy26sr9YbMoeGaAIMywIaDm+Yc2sbKKVDcr2lKP1c6KHd0Ugb0WwxojH8M1aGBUtgwYIFCxYsgQUL1iYofkeB1Q/mcwQFqw3MzQgrHkwlOglGCJZ2B9YdwIhMgpGAJfKWJ1qioD8mrIWXAAAAAElFTkSuQmCC)';

var cursorIcon = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAIxJREFUeNpi/P//PwMlgJGR0QBIfQCa84ASc5gYKAcTgDiBUkOo4RCqgFGHjDpk1CGjDhl1yKhDRoxDGIFYgcJqPAVK3yHXAGBbxoEF1KgBYgcKHPIHiEHmHKCgcaXASIUWWgPIIyBfjSbWUYeMOmTUIaMOGXXIqEOGVMOICs0AUMNKAGjOBUrMAQgwAFWiHzqojsmJAAAAAElFTkSuQmCC)16 16, auto';

var markerOffsets = {
  markerOffsetWidth: 30, // .pushpin-billboard-marker height + (border*2)
  selectedMarkerOffsetWidth: 38 // .pushpin-billboard-marker.selected height + (border*2)
};

var thumbnailOriginalPixelSize = 200; // Original crop size
var thumbnailSize = 800; // Output size of the thumbnail
var thumbnailZoom = thumbnailSize / thumbnailOriginalPixelSize;
var thumbnailMarkerRadius = 10 * thumbnailZoom;

// ATTRIBUTES_VERSION is used in order to track changes of the pushpin attributes.
// Change this number only if there is a code change that requires a distinction between pushpins created before & after that change.
//
// V1: Legacy pushpins
// V2: applyOffsetToCutplanes is being applied to pushpins' cutplanes. https://git.autodesk.com/A360/firefly.js/pull/3046
var ATTRIBUTES_VERSION = 2;

/***/ }),

/***/ "./extensions/Pushpins/PushPinEvents.js":
/*!**********************************************!*\
  !*** ./extensions/Pushpins/PushPinEvents.js ***!
  \**********************************************/
/*! exports provided: PUSHPIN_EVENTS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PUSHPIN_EVENTS", function() { return PUSHPIN_EVENTS; });
var PUSHPIN_EVENTS = {
  PUSH_PIN_CREATION_START_EVENT: 'pushpin.creation.start',
  PUSH_PIN_CREATION_END_EVENT: 'pushpin.creation.end',
  PUSH_PIN_PREPARING_THUMBNAIL: 'pushpin.preparing.thumbnail',
  PUSH_PIN_CREATED_EVENT: 'pushpin.created',
  PUSH_PIN_SELECTED_EVENT: 'pushpin.selected',
  PUSH_PIN_REMOVED_EVENT: 'pushpin.removed',
  PUSH_PIN_REMOVE_ALL_EVENT: 'pushpin.remove.all',
  PUSH_PIN_MODIFY_EVENT: 'pushpin.modified', // this will be fired on push pin position changed.
  PUSH_PIN_UPDATE_EVENT: 'pushpin.update', // this will be fired on an explicit push pin data update.
  PUSH_PIN_VISIBILITY_EVENT: 'pushpin.visibility.changed',
  PUSH_PIN_ITEMS_LOADED: 'pushpin.tool.items.loaded',

  // Separate events to distinguish that they are triggered from client by direct API call.
  // This is a workaround to fix some problems on mobile client.
  // Mobile is going to rely on this event to get push pin select status.
  PUSH_PIN_CLICKED_EVENT: 'pushpin.clicked',
  PUSH_PIN_SELECT_NONE: 'pushpin.select.none' };

/***/ }),

/***/ "./extensions/Pushpins/PushPinExtension.css":
/*!**************************************************!*\
  !*** ./extensions/Pushpins/PushPinExtension.css ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./PushPinExtension.css */ "./node_modules/css-loader/index.js!./extensions/Pushpins/PushPinExtension.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/Pushpins/PushPinExtension.js":
/*!*************************************************!*\
  !*** ./extensions/Pushpins/PushPinExtension.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PushPinExtension; });
/* harmony import */ var _PushPinEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PushPinEvents */ "./extensions/Pushpins/PushPinEvents.js");
/* harmony import */ var _PushPinManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PushPinManager */ "./extensions/Pushpins/PushPinManager.js");
/* harmony import */ var _PushPinTools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PushPinTools */ "./extensions/Pushpins/PushPinTools.js");
/* harmony import */ var _PushPinUi_IssuePushPinVisButton__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PushPinUi/IssuePushPinVisButton */ "./extensions/Pushpins/PushPinUi/IssuePushPinVisButton.js");
/* harmony import */ var _PushPinUi_RfiPushPinVisButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PushPinUi/RfiPushPinVisButton */ "./extensions/Pushpins/PushPinUi/RfiPushPinVisButton.js");
/* harmony import */ var _PushPinUi_QualityIssuePushPinVisButton__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PushPinUi/QualityIssuePushPinVisButton */ "./extensions/Pushpins/PushPinUi/QualityIssuePushPinVisButton.js");
/* harmony import */ var _PushPinObserver__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PushPinObserver */ "./extensions/Pushpins/PushPinObserver.js");
/* harmony import */ var _PushPinLegacyFallback__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PushPinLegacyFallback */ "./extensions/Pushpins/PushPinLegacyFallback.js");
/* harmony import */ var _PushPinExtension_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./PushPinExtension.css */ "./extensions/Pushpins/PushPinExtension.css");
/* harmony import */ var _PushPinExtension_css__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_PushPinExtension_css__WEBPACK_IMPORTED_MODULE_8__);
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}








 // REQUIRED!!

var namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');var

PushPinExtension = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(PushPinExtension, _Autodesk$Viewing$Ext);
  function PushPinExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, PushPinExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PushPinExtension).call(this, viewer, options));
    _this.viewer = viewer;
    _this.options = options;return _this;
  }_createClass(PushPinExtension, [{ key: "load", value: function load()

    {
      this.pushPinManager = new _PushPinManager__WEBPACK_IMPORTED_MODULE_1__["default"](this.viewer, this.options);

      this.tool = new _PushPinTools__WEBPACK_IMPORTED_MODULE_2__["default"](this.viewer, this.pushPinManager, this.options);
      this.pushpinsByType = this.pushPinManager.getInitialPushpinsByType();

      if (Autodesk.Viewing.isMobileDevice()) {
        this.observer = new _PushPinObserver__WEBPACK_IMPORTED_MODULE_6__["default"](this);
      }

      if (this.viewer.toolController) {
        this.viewer.toolController.registerTool(this.tool);
        this.viewer.toolController.activateTool(this.tool.getName());

        this.createUI();
        return true;
      }

      return false;
    } }, { key: "unload", value: function unload()

    {
      this.destroyUI();

      if (this.pushPinManager) {
        this.pushPinManager.selectNone();
        this.pushPinManager.removeAllItems();
        this.pushPinManager = null;
      }

      if (this.tool) {
        this.viewer.toolController.deregisterTool(this.tool);
        this.tool = null;
      }

      return true;
    }

    /**
       * Public interfaces routing to tool for clients to call
       */ }, { key: "startCreateItem", value: function startCreateItem(
    data) {
      this.tool.startCreateItem(data);
      this.updateButtonsStatus();
    } }, { key: "endCreateItem", value: function endCreateItem()

    {
      this.tool.endCreateItem();
      this.updateButtonsStatus();
    } }, { key: "showAll", value: function showAll()

    {
      for (var type in this.pushPinManager.PushPinTypes) {
        this.showByType(this.pushPinManager.PushPinTypes[type]);
      }
    } }, { key: "hideAll", value: function hideAll()

    {
      for (var type in this.pushPinManager.PushPinTypes) {
        this.hideByType(this.pushPinManager.PushPinTypes[type]);
      }
    } }, { key: "enableItemSelect", value: function enableItemSelect(

    enable) {
      this.tool.enablePushPinSelect(enable);
    } }, { key: "updatePattern", value: function updatePattern(

    id, size, res) {
      this.tool.renderTool.updatePattern(id, size, res);
    }

    // public interfaces routing to push pin manager for clients to call
  }, { key: "loadItems", value: function loadItems(pushPinDatas) {
      this.tool.show(true);
      this.pushPinManager.addItems(pushPinDatas);
    } }, { key: "loadItemFromLocal", value: function loadItemFromLocal(

    pushPinData) {
      this.pushPinManager.addItems([pushPinData], true, this.viewer);
    } }, { key: "updateItemById", value: function updateItemById(

    id, data) {
      return this.pushPinManager.updateItemById(id, data);
    } }, { key: "getItemById", value: function getItemById(

    id) {
      var item = this.pushPinManager.getItemById(id);

      if (item) {
        return item.data;
      }

      return null;
    } }, { key: "setDraggableById", value: function setDraggableById(

    id, isDraggable, cancelPositionChange) {
      var item = this.pushPinManager.getItemById(id);

      if (item) {
        if (cancelPositionChange) {
          item.setPosition(this.origItemPosition);
        }

        item.draggable = isDraggable;
        this.pushPinManager.fireEvent({ type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_0__["PUSHPIN_EVENTS"].PUSH_PIN_UPDATE_EVENT, value: item });
        this.origItemPosition = Object.assign({}, item.data.position);
      }
    } }, { key: "setVisibleById", value: function setVisibleById(

    id, isVisible) {
      var item = this.pushPinManager.getItemById(id);
      if (item) {
        item.visible = isVisible;
        this.pushPinManager.fireEvent({ type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_0__["PUSHPIN_EVENTS"].PUSH_PIN_UPDATE_EVENT, value: item });
      }
    } }, { key: "selectOne", value: function selectOne(

    id) {
      this.pushPinManager.selectOne(id);
    } }, { key: "selectNone", value: function selectNone()

    {
      this.pushPinManager.selectNone();
    } }, { key: "removeItemById", value: function removeItemById(

    id) {
      var item = this.pushPinManager.getItemById(id);

      if (!item) {
        return;
      }

      this.pushPinManager.removeItemById(id);
    } }, { key: "removeItemsByType", value: function removeItemsByType(

    type) {
      this.pushPinManager.removeItemsByType(type);
    } }, { key: "removeAllItems", value: function removeAllItems()

    {
      this.pushPinManager.removeAllItems();
    } }, { key: "addEventListener", value: function addEventListener(

    event, func) {
      this.pushPinManager.addEventListener(event, func);
    } }, { key: "removeEventListener", value: function removeEventListener(

    event, func) {
      this.pushPinManager.removeEventListener(event, func);
    } }, { key: "hasEventListener", value: function hasEventListener(

    event, func) {
      this.pushPinManager.hasEventListener(event, func);
    } }, { key: "createUI", value: function createUI()

    {
      this.uiButtons = [];

      if (!this.options.hideIssuesButton) {
        this.uiButtons.push(new _PushPinUi_IssuePushPinVisButton__WEBPACK_IMPORTED_MODULE_3__["default"](this.viewer, this, this.options.initiallyHideIssuesPushpins));
      }

      if (!this.options.hideFieldIssuesButton) {
        this.uiButtons.push(new _PushPinUi_QualityIssuePushPinVisButton__WEBPACK_IMPORTED_MODULE_5__["default"](this.viewer, this, this.options.initiallyHideFieldIssuesPushpins));
      }

      if (!this.options.hideRfisButton) {
        this.uiButtons.push(new _PushPinUi_RfiPushPinVisButton__WEBPACK_IMPORTED_MODULE_4__["default"](this.viewer, this, this.options.initiallyHideRfisPushpins));
      }

      if (this.viewer.model) {
        // If model is already loaded, then check.
        this.uiButtons.forEach(function (uiButton) {
          uiButton.addButton();
        });
        return;
      }

      var self = this;

      function enableVisButton() {
        if (self.viewer.model) {
          self.uiButtons.forEach(function (uiButton) {
            uiButton.addButton();
          });
        }
        self.viewer.removeEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, enableVisButton);
      }

      // Otherwise, watch model loaded event.
      this.viewer.addEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, enableVisButton);
    } }, { key: "destroyUI", value: function destroyUI()

    {
      this.uiButtons.forEach(function (uiButton) {
        uiButton.destroyButton();
      });
    } }, { key: "updateButtonsStatus", value: function updateButtonsStatus()

    {
      this.uiButtons.forEach(function (uiButton) {
        uiButton.updateButtonStatus();
      });
    } }, { key: "hideByType", value: function hideByType(

    type) {
      this.pushPinManager && this.pushPinManager.setVisibleByType(type, false);
    } }, { key: "showByType", value: function showByType(

    type) {
      this.pushPinManager && this.pushPinManager.setVisibleByType(type, true);
    }

    // Convert legacy 3D pushPinData in-place to make sure that positions and viewerState are consistently in model-local coords.
  }, { key: "legacyToLocalPushPinData", value: function legacyToLocalPushPinData(pushPinData) {

      Object(_PushPinLegacyFallback__WEBPACK_IMPORTED_MODULE_7__["legacyToLocalPushPinData"])(pushPinData, this.viewer);

      // Usually, this will be a no-op. It will just detect and auto-repair some previously saved
      // PushPins that would be broken otherwise.
      if (this.options.useLegacyFallback) {
        Object(_PushPinLegacyFallback__WEBPACK_IMPORTED_MODULE_7__["applyLegacyFallback"])(pushPinData, this.viewer);
      }
    }

    // Takes a PushPinItem and returns its PushPinData - transformed in a way that it is compatible with the PushPins as stored in issues-backend. For this, pushPin position
    // must match with viewer coordinates when using a single model with default loadOptions (default globalOffset and no transforms).
  }, { key: "getLegacyPushPinData", value: function getLegacyPushPinData(pushPin) {
      return Object(_PushPinLegacyFallback__WEBPACK_IMPORTED_MODULE_7__["getLegacyPushPinData"])(pushPin, this.viewer);
    } }]);return PushPinExtension;}(Autodesk.Viewing.Extension);


namespace.PUSH_PIN_EXT_NAME = 'Autodesk.BIM360.Extension.PushPin';
Object.assign(namespace, _PushPinEvents__WEBPACK_IMPORTED_MODULE_0__["PUSHPIN_EVENTS"]);
Autodesk.Viewing.theExtensionManager.registerExtension(namespace.PUSH_PIN_EXT_NAME, PushPinExtension);

/***/ }),

/***/ "./extensions/Pushpins/PushPinInputHandler.js":
/*!****************************************************!*\
  !*** ./extensions/Pushpins/PushPinInputHandler.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PushPinInputHandler; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var PushPinInputHandler = /*#__PURE__*/function () {
  function PushPinInputHandler(pushpinRenderer) {_classCallCheck(this, PushPinInputHandler);
    this.pushpin = null;
    this.pushpinRenderer = pushpinRenderer;
    this.mousePosition = { x: 0, y: 0 };

    this.onTouchDragBinded = this.onTouchDrag.bind(this);
    this.onMouseMoveBinded = this.onMouseMove.bind(this);
    this.onMouseUpBinded = this.onMouseUp.bind(this);
    this.onMouseDownBinded = this.onMouseDown.bind(this);
    this.onHammerInputBinded = this.onHammerInput.bind(this);

    this.mouseEnabled = false;
    this.mousePrevValue = false;
    this.lock = false;
  }

  // Convert Hammer touch-event X,Y into mouse-event X,Y.
  _createClass(PushPinInputHandler, [{ key: "processMouseEvent", value: function processMouseEvent(





    event) {
      this.mousePosition.x = event.clientX;
      this.mousePosition.y = event.clientY;
    } }, { key: "attachTo", value: function attachTo(

    pushpin) {
      if (this.pushpin) {
        this.detach();
      }

      this.pushpin = pushpin;

      if (Autodesk.Viewing.isTouchDevice()) {
        this.hammer = new Autodesk.Viewing.Hammer.Manager(pushpin, {
          recognizers: [
          Autodesk.Viewing.GestureRecognizers.drag],

          inputClass: Autodesk.Viewing.isIE11 ? Hammer.PointerEventInput : Hammer.TouchInput });


        this.hammer.on('dragstart dragmove dragend', this.onTouchDragBinded);
        this.hammer.on('hammer.input', this.onHammerInputBinded);
      }

      if (!Autodesk.Viewing.isMobileDevice()) {
        this.enableMouseButtons(true);
      }
    } }, { key: "onHammerInput", value: function onHammerInput(

    event) {
      this.setMouseDisabledWhenTouching(event);
    } }, { key: "setMouseDisabledWhenTouching", value: function setMouseDisabledWhenTouching(

    event) {var _this = this;
      if (event.isFirst && !this.lock) {
        this.enableMouseButtons(false);
        this.lock = true;
      } else if (event.isFinal) {
        setTimeout(function () {
          _this.enableMouseButtons(_this.mousePrevValue);
          _this.lock = false;
        }, 10);
      }
    } }, { key: "enableMouseButtons", value: function enableMouseButtons(

    state) {
      if (state && !this.mouseEnabled) {
        this.pushpin.addEventListener('mousedown', this.onMouseDownBinded);
        this.pushpinRenderer.viewer.container.addEventListener('mousemove', this.onMouseMoveBinded);
        this.pushpinRenderer.viewer.container.addEventListener('mouseup', this.onMouseUpBinded);
      } else if (!state && this.mouseEnabled) {
        this.pushpin.removeEventListener('mousedown', this.onMouseDownBinded);
        this.pushpinRenderer.viewer.container.removeEventListener('mousemove', this.onMouseMoveBinded);
        this.pushpinRenderer.viewer.container.removeEventListener('mouseup', this.onMouseUpBinded);
      }

      this.mousePrevValue = this.mouseEnabled;
      this.mouseEnabled = state;
    } }, { key: "detach", value: function detach()

    {
      if (this.hammer) {
        this.hammer.destroy();
      }

      this.pushpinRenderer.viewer.container.removeEventListener('mousemove', this.onMouseMoveBinded);
      this.pushpinRenderer.viewer.container.removeEventListener('mouseup', this.onMouseUpBinded);

      if (this.pushpin) {
        this.pushpin.removeEventListener('mousedown', this.onMouseDownBinded);

        this.pushpin = null;
      }

      this.mouseEnabled = false;
    } }, { key: "onMouseMove", value: function onMouseMove(

    event) {
      this.processMouseEvent(event);
      this.pushpinRenderer.handleMouseMove(event);
      event.preventDefault();
    } }, { key: "onMouseDown", value: function onMouseDown(

    event) {
      this.processMouseEvent(event);
      this.pushpinRenderer.handleMouseDown(event);
      event.preventDefault();
    } }, { key: "onMouseUp", value: function onMouseUp(

    event) {
      this.processMouseEvent(event);
      this.pushpinRenderer.handleMouseUp(event);
      event.preventDefault();
    } }, { key: "onTouchDrag", value: function onTouchDrag(

    event) {
      PushPinInputHandler.convertEventHammerToMouse(event);
      switch (event.type) {
        case 'dragstart':
          this.onMouseDown(event);
          break;
        case 'dragmove':
          this.onMouseMove(event);
          break;
        case 'dragend':
          this.onMouseUp(event);
          break;
        default:
          break;}


      event.preventDefault();
    } }], [{ key: "convertEventHammerToMouse", value: function convertEventHammerToMouse(event) {event.shiftKey = false;event.clientX = event.pointers[0].clientX;event.clientY = event.pointers[0].clientY;} }]);return PushPinInputHandler;}();


var namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');
namespace.PushPinInputHandler = PushPinInputHandler;

/***/ }),

/***/ "./extensions/Pushpins/PushPinItem.js":
/*!********************************************!*\
  !*** ./extensions/Pushpins/PushPinItem.js ***!
  \********************************************/
/*! exports provided: findMatchingModel, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findMatchingModel", function() { return findMatchingModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PushPinItem; });
/* harmony import */ var _PushPins3D_PushPinViewerState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PushPins3D/PushPinViewerState */ "./extensions/Pushpins/PushPins3D/PushPinViewerState.js");
/* harmony import */ var _PushPinConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PushPinConstants */ "./extensions/Pushpins/PushPinConstants.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');




var decodeUrn = function decodeUrn(urn) {
  urn = urn.replace(/-/g, '+'); // Convert '-' (dash) to '+'
  urn = urn.replace(/_/g, '/'); // Convert '_' (underscore) to '/'
  while (urn.length % 4) {urn += '=';} // Add padding '='
  return atob(urn);
};

// Extract the lineageID string from a base64-encoded version urn
// Example: dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuM3Q4QlBZQXJSSkNpZkFZUnhOSnM0QT92ZXJzaW9uPTI 
//          => (decoded) "urn:adsk.wipstg:fs.file:vf.3t8BPYArRJCifAYRxNJs4A?version=2"
//          => vf.3t8BPYArRJCifAYRxNJs4A
var getLineageId = function getLineageId(encodedUrn) {
  var decoded = decodeUrn(encodedUrn);
  var start = decoded.indexOf('file:') + 'file:'.length; // skip prefix "urn:adsk.wipstg:fs.file:" resp. "urn:adsk.wipprod:fs.file:"
  var end = decoded.indexOf('?');
  return decoded.substring(start, end);
};

// Returns the first visible model for which the lineageID is the same as for the given seedUrn.
// The is usually not more than 1 anyway, but not guaranteed to be. In case there are more (e.g. for diff), 
// the first matching model determines the issue position.
var findMatchingModel = function findMatchingModel(viewer, seedUrn) {

  // Extract decoded lineage urn from seedUrn
  // We ignore the version part, so that the visible model is also found if it is another model version.
  // Note: If the model is outside the version range of the issue, it will
  //		   not be displayed anyway, so that we don't have to check the version here again.
  var issueLineageId = getLineageId(seedUrn);

  // Find model with matching lineageId
  var models = viewer.getVisibleModels();
  for (var i = 0; i < models.length; i++) {

    // get lineageId of next model
    var model = models[i];
    var urn = model.myData.urn;
    var lineageId = getLineageId(urn);

    // return model if matching
    if (lineageId === issueLineageId) {
      return model;
    }
  }

  // We didn't find any model that matches the given issue. This should not happen, because 
  // issues are not supposed to be displayed if it doesn't belong to any visible model. 
  // TODO: Investigate whether the assumption above might be temporarily broken due to async calls. E.g., if a model
  //       was toggled off shortly before the issue was received.
  console.error('Issue seedUrn does not match with any visible model urn.');
};

// Unique id for runtime-generated PushPinItems. Note that the id will be overwritten by actual GUIDs if issues are saved or loaded.
// Note: It would be cleaner to consistently use guids in the first place. But, this requires some refactoring first to get rid
//       of a hack in RenderHandler.createRenderItem (https://git.autodesk.com/fluent/lmv.js/blob/develop/extensions/Pushpins/PushPins3D/RenderHandler3D.js#L188),
//       which uses the ID length to distinguish between loaded and newly created issues.
var _nextPushPinId = 1;var

PushPinItem = /*#__PURE__*/function () {
  function PushPinItem() {_classCallCheck(this, PushPinItem);
    this.itemData = {
      id: (_nextPushPinId++).toString(),
      attributesVersion: _PushPinConstants__WEBPACK_IMPORTED_MODULE_1__["ATTRIBUTES_VERSION"],
      label: 'New',
      status: 'issues-open',
      position: { x: 0, y: 0, z: 0 },
      type: 'issues',
      objectId: null,
      externalId: null,
      viewerState: null,
      objectData: null };


    // Params affect render or interaction
    this.selected = false;
    this.isVisible = true;
    this.draggable = false;
    this.selectable = true;
  }_createClass(PushPinItem, [{ key: "defaultAppearance", value: function defaultAppearance()

















    {
      var normalSize = 40;
      var selectedSize = 60;

      return {
        normalSize: normalSize,
        selectedSize: selectedSize,
        draggableStatus: '-movable',
        selectedStatus: '-selected' };

    } }, { key: "set", value: function set(

    data) {
      this.itemData = Object.assign({}, this.itemData, data);
      this.correctDataFormat();

      return this;
    }

    // Like set, but performs a conversion of position and viewerState from model-local-coords to viewer-coords.
    // PushPinItems store viewer coordinates, i.e., ready-to-render for the current viewer. Expected input is 
    // in model-local coordinates, i.e., excluding any load-time transforms.
    //
    // Note that the model of the Pushpin must be visible/loaded.
  }, { key: "setLocal", value: function setLocal(data, viewer) {

      this.set(data);

      // Positions are specified relative to the model the issue belongs to. We have to find this model first.
      var model = this.findModel(viewer);
      if (!model) {
        // If we ever see this message, we are trying to create an issue for a model that is not shown.
        // If this actually happens, we need some additional fallback logic here, e.g.
        // set position to undefined first and update on model-show events.
        console.error('PushPin coordinate conversion failed: PushPin must belong to a visible model.');
        return;
      }

      // Why creating a new vector here instead of converting in-place:
      //  - this.itemData is only a shallow copy and we don't want to modify the src input data
      //  - Original vectors cannot be assumed to be THREE types.
      this.itemData.position = new THREE.Vector3().copy(this.itemData.position);

      // Apply matrix that combines all transforms that have been applied to the model during loading.
      // Note that modelTf may be undefined. This is no error, but just indicates that neither placement nor offset was applied to the model.
      var modelTf = model.myData.placementWithOffset;
      if (modelTf) {
        this.itemData.position.applyMatrix4(modelTf);
      }

      // Apply this transforms to position. 

      // Replace viewerState by transformed copy
      // Note that we cannot use placementWithOffset here as we did for position. To make it more confusing,
      // there is another legacy constraint: viewerState values are currently stored in world-coords, i.e., viewer-coords with added 
      // global offset. The current globalOffset is subtracted when applying the viewerState (see PushPinViewerState.js:restoreViewState).
      // 
      // It would be easier and more consistent to store viewerState in viewer-coords as well. But this would currently break legacy code,
      // e.g., older issue-UI versions that don't use createItemFromLocal() are working based on the assumption that viewerStates are in world-coords.
      var placementTf = model.myData.placementTransform;
      this.itemData.viewerState = JSON.parse(JSON.stringify(this.itemData.viewerState));

      // Transform viewer state. Note that placementTf may be undefined if the model was loaded without any placement transform.
      // This is okay and just means that we can skip the transform step.
      if (placementTf) {
        Object(_PushPins3D_PushPinViewerState__WEBPACK_IMPORTED_MODULE_0__["transformViewerState"])(this.itemData.viewerState, placementTf);
      }
    }

    // Returns a copy of the PushPin itemData where position and viewerState are provided in model-local coords.
    // The model that the issue is assigned to must be visible.
  }, { key: "getLocal", value: function getLocal(viewer) {

      // Find the model for which the issue was assigned
      var model = this.findModel(viewer);
      if (!model) {
        console.error('PushPin coordinate conversion failed: PushPin must belong to a visible model.');
        return;
      }

      var localData = Object.assign({}, this.itemData);

      // Create copies of position and viewerState, so that they can be safely transformed and passed outside.
      localData.position = new THREE.Vector3().copy(this.itemData.position);
      localData.viewerState = JSON.parse(JSON.stringify(this.itemData.viewerState));

      // Get matrices to convert between different coordinate spaces. 
      // Note that both matrices may be undefined. This is no error and just indicates that the two coordinate
      // spaces are the same. 
      var modelLocalToViewer = model.myData.placementWithOffset;
      var modelLocalToWorld = model.myData.placementTransform;

      // Convert position from viewer coords to model-local coords.
      if (modelLocalToViewer) {
        var viewerToModelLocal = new THREE.Matrix4().getInverse(modelLocalToViewer);
        localData.position.applyMatrix4(viewerToModelLocal);
      }

      // Convert viewerState from world-coords to model-local coords.
      if (modelLocalToWorld) {
        // Create copy of the viewerState that is transformed from world-coords to model-local coords.
        var worldToModelLocal = new THREE.Matrix4().getInverse(modelLocalToWorld);
        Object(_PushPins3D_PushPinViewerState__WEBPACK_IMPORTED_MODULE_0__["transformViewerState"])(localData.viewerState, worldToModelLocal);
      }

      return localData;
    } }, { key: "setObjectId", value: function setObjectId(

    dbId) {
      this.itemData.objectId = dbId;
    } }, { key: "setObjectData", value: function setObjectData(

    res) {
      var model = res.model;
      if (!model) {
        return;
      }
      var data = model.getData();
      if (!data) {
        return;
      }
      var documentNode = model.getDocumentNode();
      if (!documentNode) {
        return;
      }
      var docNodeData = documentNode.data;
      if (!docNodeData) {
        return;
      }
      this.itemData.objectData = {
        guid: docNodeData.guid,
        urn: data.urn,
        viewableId: docNodeData.viewableID,
        viewName: docNodeData.name };

    } }, { key: "setExternalId", value: function setExternalId(

    externalId) {
      this.itemData.externalId = externalId;
    } }, { key: "setPosition", value: function setPosition(

    newPos) {
      this.itemData.position = Object.assign({}, newPos);
    } }, { key: "hasPosition", value: function hasPosition()

    {
      return this.itemData.position.x !== null && this.itemData.position.y !== null && this.itemData.position.z !== null;
    }

    // Finds the visible model whose lineageId matches the seedUrn stored for this issue.
    // May return undefined if the model is currently not visible.
  }, { key: "findModel", value: function findModel(viewer) {
      // TODO: Find out why for serialized issues, it is called "seedUrn" while for newly created PushPins it is called "seedURN". In LMV viewer states, it was 
      //       always "seedURN" since several years.
      var seedUrn = this.itemData.viewerState.seedUrn || this.itemData.viewerState.seedURN;
      return findMatchingModel(viewer, seedUrn);
    } }, { key: "setViewerState", value: function setViewerState(

    state) {
      this.itemData.viewerState = Object.assign({}, state);
    } }, { key: "setOriginalDocumentResolution", value: function setOriginalDocumentResolution(

    originalDocumentResolution) {
      this.setViewerState({ originalDocumentResolution: originalDocumentResolution });
    } }, { key: "correctDataFormat", value: function correctDataFormat()

    {var _this = this;
      var defaultStatusNames = [
      'draft', 'draft-selected', 'draft-movable', 'open', 'open-selected',
      'open-movable', 'answered', 'answered-selected', 'answered-movable',
      'closed', 'closed-selected', 'closed-movable'];


      defaultStatusNames.forEach(function (status) {
        if (_this.itemData.status === status) {
          _this.itemData.status = "".concat(_this.itemData.type || 'issues', "-").concat(_this.itemData.status);
        }
      });
    } }, { key: "data", get: function get() {return this.itemData;} }, { key: "visible", get: function get() {return this.isVisible;}, set: function set(isVisible) {if (!this.hasPosition()) {this.isVisible = false;} else {this.isVisible = isVisible;}} }]);return PushPinItem;}();


namespace.PushPinItem = PushPinItem;

/***/ }),

/***/ "./extensions/Pushpins/PushPinLabel/HTMLPushPinLabel.js":
/*!**************************************************************!*\
  !*** ./extensions/Pushpins/PushPinLabel/HTMLPushPinLabel.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HTMLPushPinLabel; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var HTMLPushPinLabel = /*#__PURE__*/function () {
  function HTMLPushPinLabel() {_classCallCheck(this, HTMLPushPinLabel);
    this.container = document.createElement('div');
    this.container.className = 'leaflet-text-label';
    this.text = '';
    this.dirty = false;
  }_createClass(HTMLPushPinLabel, [{ key: "setParent", value: function setParent(

    parent) {
      if (this.container.parentNode) {
        this.container.parentNode.removeChild(this.container);
      }

      if (parent) {
        parent.appendChild(this.container);
      }
    } }, { key: "set", value: function set(

    textString) {
      if (this.text === textString) {
        return;
      }

      this.container.innerHTML = '<span>' + textString + '</span>';
      this.text = textString;

      var textWidth = this.container.firstChild.clientWidth;
      var bgWidth = textWidth + 20;

      if (bgWidth < 60) {
        bgWidth = 60;
      }

      this.container.style.width = bgWidth.toString() + 'px';

      var top = 10;
      var left = 0;

      if (this.container.clientWidth !== 0) {
        var containerHeight = this.container.parentNode.clientHeight;
        top += containerHeight;

        var containerWidth = this.container.parentNode.clientWidth;
        left = (containerWidth - this.container.clientWidth) * 0.5;
      } else {
        // if label client width is null, need refresh label again.
        return;
      }

      top = top.toString() + 'px';
      left = left.toString() + 'px';

      if (this.container.style.top !== top) {
        this.container.style.top = top;
      }

      if (this.container.style.left !== left) {
        this.container.style.left = left;
      }
      this.dirty = false;
    } }]);return HTMLPushPinLabel;}();


var namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');

namespace.HTMLPushPinLabel = HTMLPushPinLabel;

/***/ }),

/***/ "./extensions/Pushpins/PushPinLabel/PushPinBillboardLabel.js":
/*!*******************************************************************!*\
  !*** ./extensions/Pushpins/PushPinLabel/PushPinBillboardLabel.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PushPinBillboardLabel; });
/* harmony import */ var _PushPinLabel_HTMLPushPinLabel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PushPinLabel/HTMLPushPinLabel */ "./extensions/Pushpins/PushPinLabel/HTMLPushPinLabel.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}var

PushPinBillboardLabel = /*#__PURE__*/function (_HTMLPushPinLabel) {_inherits(PushPinBillboardLabel, _HTMLPushPinLabel);
  function PushPinBillboardLabel(marker, labelText) {var _this;_classCallCheck(this, PushPinBillboardLabel);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PushPinBillboardLabel).call(this));

    _this.createLabel(marker, labelText);
    _this.visible = true;return _this;
  }_createClass(PushPinBillboardLabel, [{ key: "createLabel", value: function createLabel(

    marker, labelText) {
      _get(_getPrototypeOf(PushPinBillboardLabel.prototype), "setParent", this).call(this, marker);
      this.update(labelText);
    } }, { key: "update", value: function update(









    labelText) {
      _get(_getPrototypeOf(PushPinBillboardLabel.prototype), "set", this).call(this, labelText);

      this.container.style.top = PushPinBillboardLabel.TOP_PADDING;
      this.container.style.left = this.container.style.width / 3 + 'px';
    } }, { key: "show", value: function show()

    {
      this.visible = true;
      this.container.style.display = 'block';
    } }, { key: "hide", value: function hide()

    {
      this.visible = false;
      this.container.style.display = 'none';
    } }, { key: "isVisible", get: function get() {return this.visible;}, set: function set(isVisible) {this.visible = isVisible;} }]);return PushPinBillboardLabel;}(_PushPinLabel_HTMLPushPinLabel__WEBPACK_IMPORTED_MODULE_0__["default"]);


PushPinBillboardLabel.TOP_PADDING = '50px';

var namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');

namespace.PushPinBillboardLabel = PushPinBillboardLabel;

/***/ }),

/***/ "./extensions/Pushpins/PushPinLegacyFallback.js":
/*!******************************************************!*\
  !*** ./extensions/Pushpins/PushPinLegacyFallback.js ***!
  \******************************************************/
/*! exports provided: legacyToLocalPushPinData, getLegacyPushPinData, applyLegacyFallback */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "legacyToLocalPushPinData", function() { return legacyToLocalPushPinData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLegacyPushPinData", function() { return getLegacyPushPinData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyLegacyFallback", function() { return applyLegacyFallback; });
/* harmony import */ var _PushPins3D_PushPinViewerState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PushPins3D/PushPinViewerState */ "./extensions/Pushpins/PushPins3D/PushPinViewerState.js");
/* harmony import */ var _PushPinItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PushPinItem */ "./extensions/Pushpins/PushPinItem.js");



// Helper function used for saving viewerStates in PushPin attributes:
// For backward compatibility, the globalOffset of the viewerState is always equal to the center of the model bbox. Here 'model'
// is the model that the issue has been created for.
// This corresponds to the default globalOffset when using globalOffset=undefined and applyRefPoint=false in the model options.
//  @param {av.Model} model for which the PushPin was created
var getLegacyGlobalOffset = function getLegacyGlobalOffset(model) {
  // The goal here is to reproduce the default globalOffset that LMV would choose for the case
  // globalOffset=undefined and applyRefPoint=false.
  //
  // It is essential NOT to use model.getBoundingBox(): Only the box in the metadata is unaffected by
  // any lmv load-time transforms.
  var boxData = model && model.myData.metadata['world bounding box'];
  var pMin = boxData.minXYZ;
  var pMax = boxData.maxXYZ;
  return {
    x: 0.5 * (pMin[0] + pMax[0]),
    y: 0.5 * (pMin[1] + pMax[1]),
    z: 0.5 * (pMin[2] + pMax[2]) };

};

// For legacy reasons, location and viewerState from issue-backend are stored in viewer-coordinates assuming that a single
// model has been loaded with default load-options in LMV, i.e.,
//  - Global offset is at the center of the model for which the issue was created.
//  - No refPointTransform or custom transform/scaling was applied in loadOptions
//
// These conditions are true in single-model viewers like BIM360Docs Viewer,
// but not in aggregated viewers like ModelCoordination and DesignCollaboration.
// To make it for all viewers in the same way, we convert position and viewerState
// in model-local coords - which are independent of load-time transforms.
// 
// @param {Object} pushPinData - pushPin data with position and viewerState. Conversion works in-place.
var legacyToLocalPushPinData = function legacyToLocalPushPinData(pushPinData, viewer) {

  // Get globalOffset
  var offset = pushPinData.viewerState.globalOffset;

  // Legacy-fallback: (consider removal of this section in April 2020)
  //   Older Issues may not have stored the globalOffset attribute, so some information is lost.
  //   For these, we have to 'recover' it using some guesswork. To avoid regression, we assume here
  //   that the issue has been created with the same globalOffset as it is viewed. The old code had
  //   made this assumption implicitly too - so it will keep the scenarios working that had worked before.
  if (!offset) {
    // Note that consistent model placement requires globalOffset to be the same for all models.
    // So, it's okay to just use viewer.model - even for aggregated views.
    offset = viewer.model && viewer.model.myData.globalOffset;
  }

  // Convert position to model-local coords
  if (offset) {
    pushPinData.position.x += offset.x;
    pushPinData.position.y += offset.y;
    pushPinData.position.z += offset.z;
  }

  // Note: Unlike position, the viewerState (eye, target, up etc.) is already in model-local coordinates, so we don't need to add anything here.
};

// Converts PushPinData from local coordinates to legacy format - to ensure compatibility with issues that were saved before introducing model-local coordinates.
var localToLegacyPushPinData = function localToLegacyPushPinData(pushPinData, model) {

  // For backward compatibility, the globalOffset is always at the center of the model. (see getLegacyGlobalOffset for details)
  pushPinData.viewerState.globalOffset = getLegacyGlobalOffset(model);

  // For backward compatibility, the model-local coords are not stored directly in position. Instead the convention is
  // model-local position is obtained by 'data.position + data.viewerState.globalOffset'. Therefore, we must subtract the globalOffset
  // before saving.
  pushPinData.position.x -= pushPinData.viewerState.globalOffset.x;
  pushPinData.position.y -= pushPinData.viewerState.globalOffset.y;
  pushPinData.position.z -= pushPinData.viewerState.globalOffset.z;
};

var getModelLocalBox = function getModelLocalBox(model) {
  var boxData = model && model.myData.metadata['world bounding box'];
  var box = new THREE.Box3();
  box.min.fromArray(boxData.minXYZ);
  box.max.fromArray(boxData.maxXYZ);
  return box;
};

// Heuristic to detect PushPins that were written while in DesignCollaboration before the positions were fixed.
// For these, position and camera will be far outside the actual model and need some auto-correction to keep correct.
var isOldDCPushPin = function isOldDCPushPin(model, data) {

  // For new issues or old ones from Docs viewer, the pushpin position is given in model-local
  // coords and is usually inside the model box.
  // For old issues from Design Collaboration, the position will be far outside of the model-local box     
  var localBox = getModelLocalBox(model);
  var dist = localBox.distanceToPoint(data.position) * model.getUnitScale();

  // If the point is more than 100m outside, consider it as an old design collaboration issue.
  // A valid issue should always be within the model box. The length of 100m is just some heuristic choice
  // to identify "clearly far outside".
  if (dist < 100) {
    return false;
  }

  // Verify that the fallback would actually provide a valid position: If the issue was actually written
  // by design-collaboration before we fixed the positions, the position should be valid when interpreted 
  // as world coords.
  var viewerBox = model.getBoundingBox();
  var pWorld = new THREE.Vector3().copy(data.position).sub(data.viewerState.globalOffset);
  return viewerBox.containsPoint(pWorld);
};

var fixOldDCPushPin = function fixOldDCPushPin(model, data) {

  // get matrix to convert position from world coords to model-local coords
  var modelLocalToWorld = model.myData.placementTransform;
  var worldToModelLocal = modelLocalToWorld && new THREE.Matrix4().getInverse(modelLocalToWorld);

  // If there is a placement transform, transform pos and viewerState from world to model-local coords.
  // If there is no placement transform, there is nothing todo.
  if (modelLocalToWorld) {
    // transform pos
    data.position = new THREE.Vector3().copy(data.position).applyMatrix4(worldToModelLocal);

    // transform viewer state
    data.viewerState = JSON.parse(JSON.stringify(data.viewerState));
    Object(_PushPins3D_PushPinViewerState__WEBPACK_IMPORTED_MODULE_0__["transformViewerState"])(data.viewerState, worldToModelLocal);
  }
};

// Gets the in-memory reporesentation of a PushPinItem and returns the data in a way that is compatible with the 
// issues saved to issues-backend. For 2D, it is just the original PushPinData. For 3D, we have to apply some coordinate transforms.
var getLegacyPushPinData = function getLegacyPushPinData(pushPin, viewer) {

  // Check whether we are editing in 2D or 3D. Actually it would be safer to check this on the pushPin, 
  // but they don't contain any information about this.
  var is3d = viewer.model && viewer.model.is3d();
  if (!is3d) {
    // For 2D, we are done here (no modifications needed).
    return pushPin.data;
  }

  // Internally, PushPinItem stores positions in viewer-coords and viewer states in world-coords.
  // Both depend on the model-load options used in the current viewer application, i.e., would not allow issues
  // between different viewing applications.
  //
  // In the PushPinAttributes, we store everything in model-local coords. These coordinates are not affected by any load-time transform.
  // Therefore, they are always the same for different LMV clients - no matter which loadOptions they are using. Also, it
  // ensures that the issues automatically "follows" the model in case the refPointTransform changed.
  var data = pushPin.getLocal(viewer);

  // When using getLocal(), position and viewerState (eye, target, ..) are consistently given in model-local coords. In a perfect world, we were done now.
  // But, for backwards compatibility with previously existing issues, we need some legacy conversions before storing the data.

  // For backward compatibility, the globalOffset is always at the center of the model. (see getLegacyGlobalOffset for details)
  var model = pushPin.findModel(viewer);
  if (!model) {
    console.error('Saving issue attributes failed: Issue must be assigned to a visible model.');
    return pushPin.data;
  }

  // Convert from model-local coords to legacy PushPins: For backward compatility, they PushPin position must match with the viewer
  // position when viewing a single model with default loadOptions (default globalOffset, no transforms).
  localToLegacyPushPinData(data, model);

  return data;
};

//
// The purpose of this function is to avoid regressions for issues that have been created...
//  - using Design Collaboration
//  - written before we made the issue positions and viewerStates compatible with BIM360Docs viewer.
//
// For these issues, PushPin positions and viewerState will be world-coords. In the past, they had worked - but only under
// the assumption that an issue is viewed under exactly the same conditions (globalOffset, model placement etc.) in which it was created.
//
// The heuristic in this section is making sure that this case keeps working - by converting position and viewerState to model-local coordinates.
//
// Note: This fallback is not needed for viewers that use LMV default loadOptions like BIM360Docs viewer.
//
// @param {Object} data - PushPinData. Same as in PushPinExtension.createItem(..). Will be modified in-place if needed.
// @param {Viewer3D} viewer
var applyLegacyFallback = function applyLegacyFallback(data, viewer) {

  // find model that the pushpin belongs to
  var model = Object(_PushPinItem__WEBPACK_IMPORTED_MODULE_1__["findMatchingModel"])(viewer, data.viewerState.seedUrn);
  if (!model) {
    return;
  }

  // Apply fallback only if we know for sure that the PushPin position would be broken otherwise.
  if (!isOldDCPushPin(model, data)) {
    return;
  }

  // Transform position and viewerState
  fixOldDCPushPin(model, data);
};

/***/ }),

/***/ "./extensions/Pushpins/PushPinManager.js":
/*!***********************************************!*\
  !*** ./extensions/Pushpins/PushPinManager.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PushPinManager; });
/* harmony import */ var _PushPinItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PushPinItem */ "./extensions/Pushpins/PushPinItem.js");
/* harmony import */ var _PushPinEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PushPinEvents */ "./extensions/Pushpins/PushPinEvents.js");
/* harmony import */ var _PushPinUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PushPinUtils */ "./extensions/Pushpins/PushPinUtils.js");
/* harmony import */ var _PushPinConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PushPinConstants */ "./extensions/Pushpins/PushPinConstants.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}




var namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');var

PushPinManager = /*#__PURE__*/function (_Autodesk$Viewing$Eve) {_inherits(PushPinManager, _Autodesk$Viewing$Eve);
  function PushPinManager(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, PushPinManager);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PushPinManager).call(this));

    _this.viewer = viewer;
    _this.options = options;

    _this.pushPinList = [];
    _this.selectedItem = null;
    _this.PushPinTypes = {
      ISSUES: 'issues',
      RFIS: 'rfis',
      QUALITY_ISSUES: 'quality_issues' };


    _this.pushPinsVisibilityByType = _this.getInitialPushpinVisibilityByType();
    _this.pushpinsByType = _this.getInitialPushpinsByType();
    _this.create = Promise.resolve();return _this;
  }_createClass(PushPinManager, [{ key: "items", value: function items()

    {
      return this.pushPinList;
    } }, { key: "getInitialPushpinsByType", value: function getInitialPushpinsByType()

    {var _this2 = this;
      var cache = {};

      Object.keys(this.PushPinTypes).forEach(function (issueTypeKey) {
        cache[_this2.PushPinTypes[issueTypeKey]] = {};
      });

      return cache;
    } }, { key: "getInitialPushpinVisibilityByType", value: function getInitialPushpinVisibilityByType()

    {var _this3 = this;
      var cache = {};

      Object.keys(this.PushPinTypes).forEach(function (typeKey) {
        cache[_this3.PushPinTypes[typeKey]] = true;
      });

      return cache;
    } }, { key: "shouldGenerateThumbnail", value: function shouldGenerateThumbnail(

    item) {
      return this.options.generateIssueThumbnail && (item.data.type === this.PushPinTypes.ISSUES || item.data.type === this.PushPinTypes.QUALITY_ISSUES) ||
      this.options.generateRFIThumbnail && item.data.type === this.PushPinTypes.RFIS;
    } }, { key: "generateThumbnail", value: function generateThumbnail(

    item) {var _this4 = this;
      if (!this.shouldGenerateThumbnail(item)) {
        return Promise.resolve(null);
      }

      return new Promise(function (resolve, reject) {var _item$data$position =
        item.data.position,x = _item$data$position.x,y = _item$data$position.y,z = _item$data$position.z; // Backup position.

        if (_this4.viewer.model.getData().isPdf) {
          Object(_PushPinUtils__WEBPACK_IMPORTED_MODULE_2__["convertPdfToLeaflet"])(_this4.viewer, item.data);
        }

        _this4.fireEvent({ type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_1__["PUSHPIN_EVENTS"].PUSH_PIN_PREPARING_THUMBNAIL, value: item });

        item.data.position = { x: x, y: y, z: z }; // Restore position.

        var width, height, zoomRatio;
        var pWorld;
        var markerPos;

        if (_this4.viewer.model.getData().isLeaflet) {
          pWorld = Object(_PushPinUtils__WEBPACK_IMPORTED_MODULE_2__["applyPdfWorldScaling"])(_this4.viewer, item.data);
        } else {
          pWorld = item.data.position;
        }

        var canvasBounds = _this4.viewer.impl.getCanvasBoundingClientRect();
        var ratio = canvasBounds.width / canvasBounds.height;

        if (ratio > 1) {
          height = Math.floor(Math.max(canvasBounds.height, _PushPinConstants__WEBPACK_IMPORTED_MODULE_3__["thumbnailSize"]));
          zoomRatio = height / canvasBounds.height;
          width = Math.floor(canvasBounds.width * zoomRatio);
        } else {
          width = Math.floor(Math.max(canvasBounds.width, _PushPinConstants__WEBPACK_IMPORTED_MODULE_3__["thumbnailSize"]));
          zoomRatio = width / canvasBounds.width;
          height = Math.floor(canvasBounds.height * zoomRatio);
        }

        var overlayRenderer = function overlayRenderer(viewer, options) {var
          height = options.height,ctx = options.ctx,target = options.target,screenshotCamera = options.screenshotCamera,onRenderDone = options.onRenderDone;var _ctx$targetToCanvas =
          ctx.targetToCanvas(target),canvas = _ctx$targetToCanvas.canvas;

          markerPos = viewer.worldToClient(pWorld, screenshotCamera).multiplyScalar(zoomRatio);

          var radius = _PushPinConstants__WEBPACK_IMPORTED_MODULE_3__["thumbnailMarkerRadius"];
          var ctx2d = canvas.getContext("2d");
          ctx2d.fillStyle = "#FF0000";
          ctx2d.beginPath();
          ctx2d.arc(markerPos.x, height - markerPos.y, radius, 0, 2 * Math.PI);
          ctx2d.closePath();
          ctx2d.fill();

          onRenderDone(canvas);
        };

        var getCropBounds = function getCropBounds(viewer, camera) {
          var cropCenter = markerPos;

          // Make sure crop won't exceed bounds.
          if (cropCenter.x + _PushPinConstants__WEBPACK_IMPORTED_MODULE_3__["thumbnailSize"] / 2 > width) {
            cropCenter.x -= cropCenter.x + _PushPinConstants__WEBPACK_IMPORTED_MODULE_3__["thumbnailSize"] / 2 - width;
          }

          if (cropCenter.y + _PushPinConstants__WEBPACK_IMPORTED_MODULE_3__["thumbnailSize"] / 2 > height) {
            cropCenter.y -= cropCenter.y + _PushPinConstants__WEBPACK_IMPORTED_MODULE_3__["thumbnailSize"] / 2 - height;
          }

          var clientBounds = new THREE.Box3().expandByPoint(cropCenter);
          clientBounds.expandByVector(new THREE.Vector3(_PushPinConstants__WEBPACK_IMPORTED_MODULE_3__["thumbnailSize"] / 2, _PushPinConstants__WEBPACK_IMPORTED_MODULE_3__["thumbnailSize"] / 2, 0));

          return clientBounds;
        };

        var bounds;

        // Zoom in with virtual camera to get the desired thumbnail size.
        if (_this4.viewer.model.is2d()) {
          var thumbnailSizeWorld = Object(_PushPinUtils__WEBPACK_IMPORTED_MODULE_2__["clientToWorld"])(_this4.viewer, _PushPinConstants__WEBPACK_IMPORTED_MODULE_3__["thumbnailOriginalPixelSize"], 0);
          var zeroWorld = Object(_PushPinUtils__WEBPACK_IMPORTED_MODULE_2__["clientToWorld"])(_this4.viewer, 0, 0);
          var size = thumbnailSizeWorld.distanceTo(zeroWorld);

          bounds = new THREE.Box3().expandByPoint(pWorld);
          bounds.expandByVector(new THREE.Vector3(size / 2, size / 2, 0));
          bounds.min.z = 0;
          bounds.max.z = 0;
        }

        var options = {
          bounds: bounds,
          getCropBounds: getCropBounds,
          overlayRenderer: overlayRenderer };


        Autodesk.Viewing.ScreenShot.getScreenShotWithBounds(
        _this4.viewer,
        width,
        height,
        function (blob, outputWidth, outputHeight) {
          if (!blob) {
            return reject('Error while preparing pushpin thumbnail.');
          }

          Autodesk.Viewing.ScreenShot.blobToImage(blob, outputWidth, outputHeight, function (img) {
            return resolve(img);
          });
        },
        options);

      }).catch(function (e) {
        // In case of an error in the screenshot creation, continue saving the pushpin with empty thumbnail.
        console.error(e);
        return null;
      });
    }

    // @param {Object} data                - Data to be copied to the PushPin. By default, it must contain a pushpin position.
    // @param {bool}   [isTriggeringEvent] - Fire PUSH_PIN_CREATED event by default
    // @param {bool}   [createFromLocal]   - By default, data.position is assumed to be in world-coords (ready-to-render for the viewer).
    //                                       If true, the position is provided in model-local coordinates instead.
    // @param {Viewer3D} [viewer}          - Only needed when createFromLocal is true: In this case, we need to find the model for this PushPin to convert the position.
  }, { key: "createItem", value: function createItem(data) {var _this5 = this;var isTriggeringEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;var createFromLocal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;var viewer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;

      if (this.getItemById(data.id)) {
        return null;
      }

      var newItem = new _PushPinItem__WEBPACK_IMPORTED_MODULE_0__["default"]();

      if (createFromLocal) {
        // Set pushPinData - assuming that position and viewerState are given in model-local coords.
        // In this case, we have to convert them to viewer-coordinates first.
        newItem.setLocal(data, viewer);
      } else {
        newItem.set(data);
      }

      this.addItem(newItem);

      if (isTriggeringEvent) {
        this.create(newItem).
        then(function () {return _this5.generateThumbnail(newItem);}).
        then(function (thumbnail) {var _newItem$data$positio =
          newItem.data.position,x = _newItem$data$positio.x,y = _newItem$data$positio.y,z = _newItem$data$positio.z; // Backup position.

          if (_this5.viewer.model.getData().isPdf) {
            Object(_PushPinUtils__WEBPACK_IMPORTED_MODULE_2__["convertPdfToLeaflet"])(_this5.viewer, newItem.data);
          }

          _this5.fireEvent({ type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_1__["PUSHPIN_EVENTS"].PUSH_PIN_CREATED_EVENT, value: newItem, thumbnail: thumbnail });

          newItem.data.position = { x: x, y: y, z: z }; // Restore position.
        });
      }

      return newItem;
    } }, { key: "addItems", value: function addItems(

    dataArray, createFromLocal, viewer) {var _this6 = this;
      dataArray.forEach(function (pushPinData) {
        if (_this6.viewer.model.getData().isPdf) {var _applyPdfWorldScaling =
          Object(_PushPinUtils__WEBPACK_IMPORTED_MODULE_2__["applyPdfWorldScaling"])(_this6.viewer, pushPinData),x = _applyPdfWorldScaling.x,y = _applyPdfWorldScaling.y,z = _applyPdfWorldScaling.z;
          pushPinData.position = { x: x, y: y, z: z };
        }

        _this6.createItem(pushPinData, false, createFromLocal, viewer);
      });

      this.fireEvent({ type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_1__["PUSHPIN_EVENTS"].PUSH_PIN_ITEMS_LOADED, value: null });
    } }, { key: "removeAllItems", value: function removeAllItems()

    {
      this.selectedItem = null;
      this.pushPinList = [];

      // Update local pushpins cache
      this.pushpinsByType = this.getInitialPushpinsByType();

      this.fireEvent({ type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_1__["PUSHPIN_EVENTS"].PUSH_PIN_REMOVE_ALL_EVENT });
    } }, { key: "addItem", value: function addItem(

    item) {
      if (item.data && item.data.id) {
        var idx = this.getItemIndexById(item.data.id);

        if (idx > -1) {
          return false;
        }

        var type = item.data.type;

        if (type && this.pushPinsVisibilityByType) {
          item.visible = this.pushPinsVisibilityByType[type];
        }

        type = type || this.PushPinTypes.ISSUES;

        // Update local pushpins cache, handle only pushpins with supported type
        if (this.pushpinsByType[type]) {
          this.pushpinsByType[type][item.data.id] = item.data;
        }

        this.pushPinList.unshift(item);
        return true;
      }
      return false;
    } }, { key: "removeItemById", value: function removeItemById(

    id) {
      if (this.selectedItem && this.selectedItem.data.id === id) {
        this.selectedItem = null;
      }
      var idx = this.getItemIndexById(id);

      if (idx > -1) {
        var item = this.pushPinList.splice(idx, 1)[0];

        var type = item.data.type;

        // Update local pushpins cache, handle only pushpins with supported type
        if (type && this.pushpinsByType[type]) {
          delete this.pushpinsByType[type][id];
        }

        this.fireEvent({ type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_1__["PUSHPIN_EVENTS"].PUSH_PIN_REMOVED_EVENT, value: item });
        return item;
      }

      return null;
    } }, { key: "removeItemsByType", value: function removeItemsByType(

    type) {var _this7 = this;
      var pushPinTypeObject = this.pushpinsByType[type] || {};

      Object.keys(pushPinTypeObject).forEach(function (id) {
        _this7.removeItemById(id);
      });
    } }, { key: "updateItemById", value: function updateItemById(

    id, data) {
      // 1. validate data & create new one
      var item = this.getItemById(id);
      if (!item) {
        return null;
      }
      var idx = this.getItemIndexById(item.data.id);

      if (!data || !data.id || data.type !== item.data.type) {
        return null;
      }

      if (this.viewer.model.getData().isPdf) {var _applyPdfWorldScaling2 =
        Object(_PushPinUtils__WEBPACK_IMPORTED_MODULE_2__["applyPdfWorldScaling"])(this.viewer, data),x = _applyPdfWorldScaling2.x,y = _applyPdfWorldScaling2.y,z = _applyPdfWorldScaling2.z;
        data.position = { x: x, y: y, z: z };
      }

      // 2. update data
      item.set(data);

      // 3. update local pushpins cache, handle only pushpins with supported type
      var type = item.data.type;

      if (type && this.pushpinsByType[type]) {
        delete this.pushpinsByType[type][id];
        this.pushpinsByType[type][item.data.id] = item.data;
      }
      this.pushPinList[idx] = item;

      this.fireEvent({ type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_1__["PUSHPIN_EVENTS"].PUSH_PIN_UPDATE_EVENT, value: item });

      return item;
    } }, { key: "getItemById", value: function getItemById(

    id) {
      var idx = this.getItemIndexById(id);
      return idx > -1 ? this.pushPinList[idx] : null;
    } }, { key: "getItemIndexById", value: function getItemIndexById(

    id) {
      var idx = -1;
      this.pushPinList.every(function (item, index) {
        if (item.data.id === id) {
          idx = index;
          return false;
        }
        return true;
      });
      return idx;
    } }, { key: "getItemCountByType", value: function getItemCountByType(

    type) {
      var pushPinTypeObject = this.pushpinsByType[type] || {};

      return Object.keys(pushPinTypeObject).length;
    } }, { key: "getSelectedItem", value: function getSelectedItem()

    {
      return this.selectedItem;
    } }, { key: "selectOne", value: function selectOne(

    id) {
      if (!this.selectedItem || this.selectedItem.data.id !== id) {
        var oldOne = this.selectedItem;
        this.selectedItem = this.getItemById(id);

        if (oldOne !== this.selectedItem) {
          oldOne && (oldOne.selected = false);
          this.selectedItem && (this.selectedItem.selected = true);
          this.fireEvent({ type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_1__["PUSHPIN_EVENTS"].PUSH_PIN_SELECTED_EVENT, value: this.selectedItem });
        }
      }

      return this.selectedItem;
    } }, { key: "selectNone", value: function selectNone()

    {
      this.selectOne(null);
    } }, { key: "getVisibleByType", value: function getVisibleByType(

    type) {
      return this.pushPinsVisibilityByType[type];
    } }, { key: "setVisibleByType", value: function setVisibleByType(

    type, isVisible) {var _this8 = this;
      this.pushPinsVisibilityByType[type] = isVisible;
      var pushPinTypeObject = this.pushpinsByType[type] || {};

      Object.keys(pushPinTypeObject).forEach(function (id) {
        var item = _this8.getItemById(id);

        if (item) {
          item.visible = isVisible;
        }
      });

      this.fireEvent({ type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_1__["PUSHPIN_EVENTS"].PUSH_PIN_VISIBILITY_EVENT, value: { type: type, isVisible: isVisible } });
    } }, { key: "addEventListener", value: function addEventListener(

    event, func) {
      if (!this.hasEventListener(event, func)) {
        _get(_getPrototypeOf(PushPinManager.prototype), "addEventListener", this).call(this, event, func);
      }
    } }, { key: "setCreateFunction", value: function setCreateFunction(

    func) {
      this.create = func;
    } }, { key: "removeCreateFunction", value: function removeCreateFunction(

    func) {
      if (func === this.create) {
        this.create = Promise.resolve();
      }
    } }]);return PushPinManager;}(Autodesk.Viewing.EventDispatcher);


namespace.PushPinManager = PushPinManager;

/***/ }),

/***/ "./extensions/Pushpins/PushPinObserver.js":
/*!************************************************!*\
  !*** ./extensions/Pushpins/PushPinObserver.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PushPinMobileObserver; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var PushPinMobileObserver = /*#__PURE__*/function () {
  function PushPinMobileObserver(pushpinExtension) {_classCallCheck(this, PushPinMobileObserver);
    this.pushpinExtension = pushpinExtension;

    this.addListeners();
  }_createClass(PushPinMobileObserver, [{ key: "addListeners", value: function addListeners()

    {
      if (!this.pushpinExtension) {
        return;
      }

      this.pushpinExtension.addEventListener(Autodesk.BIM360.Extension.PushPin.PUSH_PIN_CREATED_EVENT, function (event) {
        PushPinMobileObserver.postMessage('onPushPinCreated', event);
      });

      this.pushpinExtension.addEventListener(Autodesk.BIM360.Extension.PushPin.PUSH_PIN_PREPARING_THUMBNAIL, function (event) {
        PushPinMobileObserver.postMessage('onPushPinPreparingThumbnail', event);
      });

      this.pushpinExtension.addEventListener(Autodesk.BIM360.Extension.PushPin.PUSH_PIN_CLICKED_EVENT, function (event) {
        PushPinMobileObserver.postMessage('onPushPinActived', event);
      });

      this.pushpinExtension.addEventListener(Autodesk.BIM360.Extension.PushPin.PUSH_PIN_MODIFY_EVENT, function (event) {
        PushPinMobileObserver.postMessage('onPushPinMoved', event);
      });

      this.pushpinExtension.addEventListener(Autodesk.BIM360.Extension.PushPin.PUSH_PIN_SELECT_NONE, function (event) {
        PushPinMobileObserver.postMessage('onPushPinSelectNone', event);
      });

      this.pushpinExtension.addEventListener(Autodesk.BIM360.Extension.PushPin.PUSH_PIN_UPDATE_EVENT, function (event) {
        PushPinMobileObserver.postMessage('onPushPinUpdated', event);
      });

      this.pushpinExtension.addEventListener(Autodesk.BIM360.Extension.PushPin.PUSH_PIN_ITEMS_LOADED, function (event) {
        PushPinMobileObserver.postMessage('onPushPinItemsLoaded', event);
      });

      PushPinMobileObserver.postMessage('onPushPinToolLoaded', {});
    } }], [{ key: "postMessage", value: function postMessage(

    messageName, event) {
      var pushPinItem = event.value;
      var thumbnail = event.thumbnail || '';

      var metadata = {};

      if (pushPinItem) {
        metadata = {
          id: pushPinItem.data.id,
          label: pushPinItem.data.label,
          status: pushPinItem.data.status,
          position: {
            x: pushPinItem.data.position.x,
            y: pushPinItem.data.position.y,
            z: pushPinItem.data.position.z },

          type: pushPinItem.data.type,
          objectId: pushPinItem.data.objectId,
          externalId: pushPinItem.data.externalId,
          viewerState: pushPinItem.data.viewerState,
          attributesVersion: pushPinItem.data.attributesVersion };

      }

      if (window.webkit !== undefined) {
        // New iOS SDK uses a standard callback method with the pattern of "command" and "data", just like MobileCallbacks.js
        window.webkit.messageHandlers.callbackHandler.postMessage({ command: messageName, data: { metadata: metadata, thumbnail: thumbnail } });
      } else if (window.JSINTERFACE) {
        // Android
        if (!pushPinItem) {
          window.JSINTERFACE[messageName]();
        } else {
          window.JSINTERFACE[messageName](metadata.id, metadata.type, metadata.label, metadata.status,
          metadata.position.x, metadata.position.y, metadata.position.z, metadata.objectId,
          JSON.stringify(metadata.viewerState), metadata.externalId, metadata.attributesVersion, thumbnail);
        }
      }
    } }]);return PushPinMobileObserver;}();

/***/ }),

/***/ "./extensions/Pushpins/PushPinTools.js":
/*!*********************************************!*\
  !*** ./extensions/Pushpins/PushPinTools.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PushPinTool; });
/* harmony import */ var _PushPinEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PushPinEvents */ "./extensions/Pushpins/PushPinEvents.js");
/* harmony import */ var _PushPinUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PushPinUtils */ "./extensions/Pushpins/PushPinUtils.js");
/* harmony import */ var _PushPinConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PushPinConstants */ "./extensions/Pushpins/PushPinConstants.js");
/* harmony import */ var _PushPins2D_RenderHandler2D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PushPins2D/RenderHandler2D */ "./extensions/Pushpins/PushPins2D/RenderHandler2D.js");
/* harmony import */ var _PushPins3D_RenderHandler3D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PushPins3D/RenderHandler3D */ "./extensions/Pushpins/PushPins3D/RenderHandler3D.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var

PushPinTool = /*#__PURE__*/function () {
  function PushPinTool(viewer, pushPinManager) {var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};_classCallCheck(this, PushPinTool);
    this.names = ['pushpin'];
    this.priority = 65;
    this.pushpinCursor = _PushPinConstants__WEBPACK_IMPORTED_MODULE_2__["cursorIcon"];

    this.isActive = false;
    this.pushPinInitData = null;
    this.viewer = viewer;
    this.pushPinManager = pushPinManager;
    this.createMode = false;

    // This is for test
    this.testId = '1111122222333334444455555';
    this.autoCreate = false;
    // test end

    this.is2D = this.viewer.model && this.viewer.model.is2d();

    // In case the 3d model has no thickness, consider it as a 'pseudo 2D' model.
    // It will disable the occlusion test. And when creating new pushpins it will not interact with the objects, but with the ground. 
    if (!this.is2D) {
      var modelBB = this.viewer.model.getBoundingBox();
      var worldUp = this.viewer.impl.worldUpName();
      this.isPseudo2D = modelBB.max[worldUp] - modelBB.min[worldUp] === 0;
      this.pushPinManager.options.disableOcclusionTest = true;
    }
  }_createClass(PushPinTool, [{ key: "getNames", value: function getNames()

    {
      return this.names;
    } }, { key: "getName", value: function getName()

    {
      return this.names[0];
    } }, { key: "getPriority", value: function getPriority()

    {
      return this.priority;
    } }, { key: "setAutoCreate", value: function setAutoCreate(

    auto) {
      this.autoCreate = auto;
    } }, { key: "getCursor", value: function getCursor()

    {
      if (this.createMode) {
        return this.pushpinCursor;
      }
      return this.isHover ? 'pointer' : null;
    } }, { key: "register", value: function register()

    {
      // Init render tool
      if (!this.renderTool) {
        if (this.is2D) {
          this.renderTool = new _PushPins2D_RenderHandler2D__WEBPACK_IMPORTED_MODULE_3__["default"](this.viewer, this.pushPinManager);
        } else {
          this.renderTool = new _PushPins3D_RenderHandler3D__WEBPACK_IMPORTED_MODULE_4__["default"](this.viewer, this.pushPinManager);
        }

        this.renderTool.register();
      }
    } }, { key: "deregister", value: function deregister()

    {
      if (this.renderTool) {
        this.renderTool.deregister();
        this.renderTool = null;
      }
    } }, { key: "activate", value: function activate(

    name, viewerApi) {
      if (name === this.getName()) {
        this.renderTool.activate();
        this.isActive = true;
      }
    } }, { key: "deactivate", value: function deactivate(

    name) {
      if (name === this.getName()) {
        this.show(false);
        this.isActive = false;
      }
    } }, { key: "update", value: function update()

    {
      if (this.isActive) {
        if (this.duringShowing && this.renderTool) {
          this.renderTool.render();
        }
      }

      // return false, because push pin render doesn't affect LMV model.
      return false;
    } }, { key: "show", value: function show(

    duringShowing) {
      this.duringShowing = duringShowing;
    } }, { key: "enablePushPinSelect", value: function enablePushPinSelect(

    enable) {
      this.pushPinManager.items().forEach(function (item) {
        item.selectable = enable;
      });
    }

    // Each time client initiate push pin create with default info and one at a time
  }, { key: "startCreateItem", value: function startCreateItem(data) {
      if (this.isActive) {
        var controller = this.viewer.toolController;
        if (controller && controller.getActiveToolName() !== this.getName()) {
          controller.deactivateTool(this.getName());
          controller.activateTool(this.getName());
        }

        if (!this.duringShowing) {
          this.show(true);
        }

        this.pushPinInitData = data;
        this.createMode = true;
        this.enablePushPinSelect(false);
      }

      this.viewer.dispatchEvent({ type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_0__["PUSHPIN_EVENTS"].PUSH_PIN_SELECTED_EVENT });
    } }, { key: "endCreateItem", value: function endCreateItem()

    {
      this.pushPinInitData = null;

      if (this.createMode) {
        this.createMode = false;
        this.enablePushPinSelect(true);
      }
    } }, { key: "createThreePushPin", value: function createThreePushPin(

    event) {
      var pushPin = null;
      var clientX = event.canvasX;
      var clientY = event.canvasY;
      var result;
      if (!this.isPseudo2D) {
        result = this.viewer.impl.clientToWorld(clientX, clientY);
      } else {
        result = {
          point: this.viewer.impl.intersectGround(clientX, clientY) };

      }

      if (result && this.pushPinInitData) {
        this.pushPinInitData.position = { x: result.point.x, y: result.point.y, z: result.point.z };

        pushPin = this.pushPinManager.createItem(this.pushPinInitData);
        // Clear pin pin init data, as it is a one time data for creating only one push pin.
        this.pushPinInitData = null;
      }

      return pushPin;
    } }, { key: "createTwoPushPin", value: function createTwoPushPin(

    event) {
      var pushPin = null;
      var clientX = event.canvasX;
      var clientY = event.canvasY;
      var result = Object(_PushPinUtils__WEBPACK_IMPORTED_MODULE_1__["clientToWorld"])(this.viewer, clientX, clientY);

      if (result && this.pushPinInitData) {
        this.pushPinInitData.position = { x: result.x, y: result.y, z: result.z };

        pushPin = this.pushPinManager.createItem(this.pushPinInitData);
        // Clear pin pin init data, as it is a one time data for creating only one push pin.
        this.pushPinInitData = null;
      }

      return pushPin;
    } }, { key: "createPushPin", value: function createPushPin(

    event) {
      if (this.autoCreate && !this.pushPinInitData) {
        // Fake push pin data for auto create.
        this.pushPinInitData = { id: this.testId + '1', status: 'issues-open', type: 'issues' };
      }

      if (this.pushPinInitData) {
        return this.viewer.model.is2d() ? this.createTwoPushPin(event) : this.createThreePushPin(event);
      }

      return false;
    }

    // Below is the standard input handler, so far only care about single click for creating push pins.
  }, { key: "handleSingleTap", value: function handleSingleTap(event) {
      PushPinTool.convertEventHammerToMouse(event);

      return this.handleSingleClick(event, 0);
    } }, { key: "triggerPushpinClick", value: function triggerPushpinClick(

    item) {
      this.pushPinManager.selectOne(item.data.id);
      this.pushPinManager.fireEvent({
        type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_0__["PUSHPIN_EVENTS"].PUSH_PIN_CLICKED_EVENT,
        value: this.pushPinManager.getSelectedItem() });

    } }, { key: "checkPushpinClick", value: function checkPushpinClick(

    event) {
      return this.renderTool.findIntersections(event);
    } }, { key: "handleSingleClick", value: function handleSingleClick(

    event, button) {
      var pressedItem = this.checkPushpinClick(event);
      var triggered = false;

      if (!this.createMode) {
        // Trigger selection only when createMode is false
        if (pressedItem) {
          this.triggerPushpinClick(pressedItem);
          triggered = true;
        } else if (this.pushPinManager.selectedItem) {
          this.pushPinManager.selectNone();
          this.pushPinManager.fireEvent({ type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_0__["PUSHPIN_EVENTS"].PUSH_PIN_SELECT_NONE, value: null });
        }
      }

      if (this.isActive && button === 0) {
        if (pressedItem) {
          if (!triggered) {
            this.triggerPushpinClick(pressedItem);
          }
        } else {
          return this.createPushPin(event);
        }
      }

      if (pressedItem) {
        // Prevent from other listeners to be alerted for this current click.
        // This is necessary for a scenario when there is a pushpin on top of a callout rectangle for example.
        document.addEventListener('click',
        function handler(e) {
          e.stopPropagation();
          document.removeEventListener('click', handler, true);
        }, true);
      }

      return !!pressedItem;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      var hoveredItem = this.checkPushpinClick(event);

      this.isHover = !!hoveredItem;
      return false;
    } }], [{ key: "convertEventHammerToMouse", value: function convertEventHammerToMouse(

    event) {
      // Convert Hammer touch-event X,Y into mouse-event X,Y.
      event.shiftKey = false;
      event.clientX = event.pointers[0].clientX;
      event.clientY = event.pointers[0].clientY;
    } }]);return PushPinTool;}();



var namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');

namespace.PushPinTool = PushPinTool;

/***/ }),

/***/ "./extensions/Pushpins/PushPinUi/IssuePushPinVisButton.js":
/*!****************************************************************!*\
  !*** ./extensions/Pushpins/PushPinUi/IssuePushPinVisButton.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IssuePushPinVisButton; });
/* harmony import */ var _PushPinUi_PushPinVisButtonBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PushPinUi/PushPinVisButtonBase */ "./extensions/Pushpins/PushPinUi/PushPinVisButtonBase.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}var

IssuePushPinVisButton = /*#__PURE__*/function (_PushPinVisButton) {_inherits(IssuePushPinVisButton, _PushPinVisButton);
  function IssuePushPinVisButton(viewer, extension, initiallyHidePushpins) {var _this;_classCallCheck(this, IssuePushPinVisButton);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(IssuePushPinVisButton).call(this, viewer, extension, initiallyHidePushpins));
    _this.viewer = viewer;
    _this.extension = extension;
    _this.pushpinVisBtn = null;

    _this.setButtonConstants();return _this;
  }_createClass(IssuePushPinVisButton, [{ key: "setButtonConstants", value: function setButtonConstants()

    {
      this.buttonConstants = {
        btnClass: 'toolbar-pushpinVis',
        btnLabel: 'Show all pushpins',
        noPushpinLabel: 'No issue in current doc',
        hidePushpinLabel: 'Hide all issues',
        showPushpinLabel: 'Show all issues',
        pushpinNormalIcon: 'issueicon-issue_normal',
        pushpinHideIcon: 'issueicon-issue_hide' };


      this.type = this.extension.pushPinManager.PushPinTypes.ISSUES;
    } }]);return IssuePushPinVisButton;}(_PushPinUi_PushPinVisButtonBase__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/Pushpins/PushPinUi/PushPinVisButtonBase.js":
/*!***************************************************************!*\
  !*** ./extensions/Pushpins/PushPinUi/PushPinVisButtonBase.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PushPinVisButton; });
/* harmony import */ var _PushPinEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PushPinEvents */ "./extensions/Pushpins/PushPinEvents.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var

PushPinVisButton = /*#__PURE__*/function () {
  function PushPinVisButton(viewer, extension, initiallyHidePushpins) {_classCallCheck(this, PushPinVisButton);
    this.viewer = viewer;
    this.extension = extension;
    this.pushpinVisBtn = null;
    this.initiallyHidePushpins = initiallyHidePushpins;

    this.setButtonConstants();
  }_createClass(PushPinVisButton, [{ key: "setButtonConstants", value: function setButtonConstants()

    {
      this.buttonConstants = {
        btnClass: '',
        btnLabel: '',
        noPushpinLabel: '',
        hidePushpinLabel: '',
        showPushpinLabel: '',
        pushpinNormalIcon: '',
        pushpinHideIcon: '' };


      this.type = '';
    } }, { key: "createButton", value: function createButton()





    {
      var btn = new Autodesk.Viewing.UI.Button(this.buttonConstants.btnClass);

      btn.setToolTip(Autodesk.Viewing.i18n.translate(this.buttonConstants.btnLabel));
      btn.setIcon(this.buttonConstants.pushpinNormalIcon);

      btn.onClick = function () {
        var state = btn.getState();
        if (state === PushPinVisButton.DISABLED) {
          return;
        }

        btn.setState(state === PushPinVisButton.INACTIVE ? PushPinVisButton.ACTIVE : PushPinVisButton.INACTIVE);
      };

      return btn;
    } }, { key: "onPushpinVisBtnStateChange", value: function onPushpinVisBtnStateChange(

    e) {
      if (e.state === PushPinVisButton.DISABLED) {
        this.pushpinVisBtn.setToolTip(Autodesk.Viewing.i18n.translate(this.buttonConstants.noPushpinLabel));
        return;
      }

      var showAll = e.state === PushPinVisButton.ACTIVE && !this.initiallyHidePushpins;
      if (this.initiallyHidePushpins) {
        this.pushpinVisBtn.setState(PushPinVisButton.INACTIVE);
        this.initiallyHidePushpins = false;
      }

      // Toggle the vis button
      if (showAll) {
        this.extension.tool.show(true);
        this.extension.showByType(this.type);
        this.pushpinVisBtn.setToolTip(Autodesk.Viewing.i18n.translate(this.buttonConstants.hidePushpinLabel));
        this.pushpinVisBtn.setIcon(this.buttonConstants.pushpinNormalIcon);
      } else {
        this.extension.hideByType(this.type);
        this.pushpinVisBtn.setToolTip(Autodesk.Viewing.i18n.translate(this.buttonConstants.showPushpinLabel));
        this.pushpinVisBtn.setIcon(this.buttonConstants.pushpinHideIcon);
      }
    } }, { key: "addButton", value: function addButton()

    {var _this = this;
      if (this.pushpinVisBtn || !this.viewer.getToolbar) {
        return;
      }

      var toolbar = this.viewer.getToolbar();

      if (!toolbar) {
        return;
      }

      var modelTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);

      if (!modelTools) {
        // insert model tool below navgiation tool
        var navigationBar = toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);
        var toolbarOptions = {};

        toolbarOptions.index = navigationBar ? toolbar.indexOf(navigationBar) + 1 : 0;

        modelTools = new Autodesk.Viewing.UI.ControlGroup(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);
        toolbar.addControl(modelTools, toolbarOptions);
      }

      this.pushpinVisBtn = this.createButton();

      // Add button to the toolbar
      this.pushpinVisBtn.addEventListener(Autodesk.Viewing.UI.Button.Event.STATE_CHANGED, function (e) {
        _this.onPushpinVisBtnStateChange(e);
      });
      this.updateButtonStatus();
      modelTools.addControl(this.pushpinVisBtn);

      // add event listener to update visual button status
      this.extension.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_0__["PUSHPIN_EVENTS"].PUSH_PIN_REMOVED_EVENT, function () {
        _this.updateButtonStatus();
      });
      this.extension.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_0__["PUSHPIN_EVENTS"].PUSH_PIN_REMOVE_ALL_EVENT, function () {
        _this.updateButtonStatus();
      });
      this.extension.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_0__["PUSHPIN_EVENTS"].PUSH_PIN_CREATED_EVENT, function () {
        _this.updateButtonStatus();
      });
      this.extension.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_0__["PUSHPIN_EVENTS"].PUSH_PIN_ITEMS_LOADED, function () {
        _this.updateButtonStatus();
      });
      this.extension.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_0__["PUSHPIN_EVENTS"].PUSH_PIN_PREPARING_THUMBNAIL, function () {
        _this.updateButtonStatus();
      });
      this.extension.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_0__["PUSHPIN_EVENTS"].PUSH_PIN_ITEMS_LOADED, function () {
        _this.updateButtonStatus();
      });
    } }, { key: "updateButtonStatus", value: function updateButtonStatus()

    {
      if (!this.pushpinVisBtn) {
        return;
      }

      // during push pin is creating, show all push pins and disable show/hide button
      if (this.extension.tool.createMode) {
        if (this.pushpinVisBtn.getState() !== PushPinVisButton.DISABLED) {
          this.pushpinVisBtn.setState(PushPinVisButton.DISABLED);
        }
      } else {
        var issuePushpinCount = this.extension.pushPinManager.getItemCountByType(this.type);
        var issueButtonDisable = this.pushpinVisBtn.getState() === PushPinVisButton.DISABLED;

        if (issuePushpinCount > 0 && issueButtonDisable) {
          this.pushpinVisBtn.setState(PushPinVisButton.ACTIVE);
        } else if (issuePushpinCount === 0 && !issueButtonDisable) {
          this.pushpinVisBtn.setState(PushPinVisButton.DISABLED);
        }
      }
    } }, { key: "destroyButton", value: function destroyButton()

    {
      if (!this.pushpinVisBtn) {
        return;
      }

      this.extension.pushPinManager.removeEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_0__["PUSHPIN_EVENTS"].PUSH_PIN_REMOVED_EVENT, this.updateButtonStatus);
      this.extension.pushPinManager.removeEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_0__["PUSHPIN_EVENTS"].PUSH_PIN_REMOVE_ALL_EVENT, this.updateButtonStatus);
      this.extension.pushPinManager.removeEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_0__["PUSHPIN_EVENTS"].PUSH_PIN_CREATED_EVENT, this.updateButtonStatus);

      var toolbar = this.viewer.getToolbar();

      if (toolbar) {
        this.pushpinVisBtn.removeFromParent();
      }

      this.pushpinVisBtn.removeEventListener(Autodesk.Viewing.UI.Button.Event.STATE_CHANGED, this.onPushpinVisBtnStateChange);
      this.pushpinVisBtn = null;
    } }, { key: "pushPinButton", get: function get() {return this.pushpinVisBtn;} }]);return PushPinVisButton;}();


PushPinVisButton.ACTIVE = Autodesk.Viewing.UI.Button.State.ACTIVE;
PushPinVisButton.DISABLED = Autodesk.Viewing.UI.Button.State.DISABLED;
PushPinVisButton.INACTIVE = Autodesk.Viewing.UI.Button.State.INACTIVE;

/***/ }),

/***/ "./extensions/Pushpins/PushPinUi/QualityIssuePushPinVisButton.js":
/*!***********************************************************************!*\
  !*** ./extensions/Pushpins/PushPinUi/QualityIssuePushPinVisButton.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return QualityIssuePushPinVisButton; });
/* harmony import */ var _PushPinUi_PushPinVisButtonBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PushPinUi/PushPinVisButtonBase */ "./extensions/Pushpins/PushPinUi/PushPinVisButtonBase.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}var

QualityIssuePushPinVisButton = /*#__PURE__*/function (_PushPinVisButton) {_inherits(QualityIssuePushPinVisButton, _PushPinVisButton);
  function QualityIssuePushPinVisButton(viewer, extension, initiallyHidePushpins) {var _this;_classCallCheck(this, QualityIssuePushPinVisButton);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(QualityIssuePushPinVisButton).call(this, viewer, extension, initiallyHidePushpins));
    _this.viewer = viewer;
    _this.extension = extension;
    _this.pushpinVisBtn = null;

    _this.setButtonConstants();return _this;
  }_createClass(QualityIssuePushPinVisButton, [{ key: "setButtonConstants", value: function setButtonConstants()

    {
      this.buttonConstants = {
        btnClass: 'toolbar-pushpinFieldIssuesVis',
        btnLabel: 'Show all field pushpins',
        noPushpinLabel: 'No field issue in current doc',
        hidePushpinLabel: 'Hide all field issues',
        showPushpinLabel: 'Show all field issues',
        pushpinNormalIcon: 'fieldissueicon-issue_normal',
        pushpinHideIcon: 'fieldissueicon-issue_hide' };


      this.type = this.extension.pushPinManager.PushPinTypes.QUALITY_ISSUES;
    } }]);return QualityIssuePushPinVisButton;}(_PushPinUi_PushPinVisButtonBase__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/Pushpins/PushPinUi/RfiPushPinVisButton.js":
/*!**************************************************************!*\
  !*** ./extensions/Pushpins/PushPinUi/RfiPushPinVisButton.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RfiPushPinVisButton; });
/* harmony import */ var _PushPinUi_PushPinVisButtonBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PushPinUi/PushPinVisButtonBase */ "./extensions/Pushpins/PushPinUi/PushPinVisButtonBase.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}var

RfiPushPinVisButton = /*#__PURE__*/function (_PushPinVisButton) {_inherits(RfiPushPinVisButton, _PushPinVisButton);
  function RfiPushPinVisButton(viewer, extension, initiallyHidePushpins) {var _this;_classCallCheck(this, RfiPushPinVisButton);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(RfiPushPinVisButton).call(this, viewer, extension, initiallyHidePushpins));
    _this.viewer = viewer;
    _this.extension = extension;
    _this.pushpinVisBtn = null;

    _this.setButtonConstants();return _this;
  }_createClass(RfiPushPinVisButton, [{ key: "setButtonConstants", value: function setButtonConstants()

    {
      this.buttonConstants = {
        btnClass: 'toolbar-pushpinRfisVis',
        btnLabel: 'Show all rfis',
        noPushpinLabel: 'No RFI in current doc',
        hidePushpinLabel: 'Hide all RFIs',
        showPushpinLabel: 'Show all RFIs',
        pushpinNormalIcon: 'rfiicon-rfi_normal',
        pushpinHideIcon: 'rfiicon-rfi_hide' };


      this.type = this.extension.pushPinManager.PushPinTypes.RFIS;
    } }]);return RfiPushPinVisButton;}(_PushPinUi_PushPinVisButtonBase__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/Pushpins/PushPinUtils.js":
/*!*********************************************!*\
  !*** ./extensions/Pushpins/PushPinUtils.js ***!
  \*********************************************/
/*! exports provided: clientToWorldLeaflet, clientToWorld, applyPdfWorldScaling, worldToClient, convertPdfToLeaflet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clientToWorldLeaflet", function() { return clientToWorldLeaflet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clientToWorld", function() { return clientToWorld; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyPdfWorldScaling", function() { return applyPdfWorldScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "worldToClient", function() { return worldToClient; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertPdfToLeaflet", function() { return convertPdfToLeaflet; });
// Compute the max level from leaflet max resolution texture.
function computeMaxLevel(w, h) {
  // compute maxLevel that we would get for 1x1 resolution at level 0
  var lx = Math.ceil(Math.log2(w));
  var ly = Math.ceil(Math.log2(h));
  var maxLevel = Math.max(lx, ly);

  // since the actual root tile has tileSize x tileSize, we subtract the skipped levels.
  return maxLevel;
}

function _clientToWorld(viewer, x, y) {
  var p = viewer.impl.clientToViewport(x, y);
  var projMatrix = viewer.impl.camera.projectionMatrix;
  var projMatrixIns = new THREE.Matrix4();
  projMatrixIns.getInverse(projMatrix);
  p.applyMatrix4(projMatrixIns);
  p.applyMatrix4(viewer.impl.camera.matrixWorld);

  return p;
}

function clientToWorldLeaflet(viewer, x, y) {
  var loadOptions;
  var bounds;

  if (viewer.model.getData().isPdf) {
    loadOptions = Autodesk.Viewing.PDFUtils.getLeafletLoadOptions(viewer);
    bounds = Autodesk.Viewing.PDFUtils.getLeafletBoundingBox(viewer);
  } else {
    var modelData = viewer.model.getData();
    loadOptions = modelData.loadOptions.loadOptions;
    bounds = modelData.bbox;
  }var _loadOptions =

  loadOptions,texWidth = _loadOptions.texWidth,texHeight = _loadOptions.texHeight;

  var worldPos = _clientToWorld(viewer, x, y);
  var worldTopLeft = new THREE.Vector3(bounds.min.x, bounds.max.y, 0);

  worldPos.sub(worldTopLeft);
  var newX = worldPos.x * texWidth / bounds.size().x;
  var newY = worldPos.y * texHeight / bounds.size().y;

  var point = new THREE.Vector3(newX, newY, 0);

  var maxLevel = computeMaxLevel(texWidth, texHeight);
  var scale = Math.pow(2, maxLevel);

  var px = point.x / scale;
  var py = point.y / scale;

  // x & y are swapped for some reason. Can't change it now for backward compatibility.
  return new THREE.Vector3(py, px, 0);
}

function clientToWorld(viewer, x, y) {
  if (viewer.model.getData().isLeaflet) {
    return clientToWorldLeaflet(viewer, x, y);
  } else {
    return _clientToWorld(viewer, x, y);
  }
};

function applyPdfWorldScaling(viewer, itemData) {
  if (viewer.model.getData().isLeaflet || viewer.model.getData().isPdf) {
    var originalDocumentResolution = itemData.viewerState && itemData.viewerState.originalDocumentResolution;

    // In case of leaflet - it changes to world coordinates.
    var clientPos = worldToClient(viewer, itemData.position, originalDocumentResolution);
    var worldPos = _clientToWorld(viewer, clientPos.x, clientPos.y);
    return worldPos;
  } else {
    return itemData.position;
  }
}

function worldToClient(viewer, point, originalDocumentResolution) {
  if (!viewer.model.getData().isLeaflet && !viewer.model.getData().isPdf) {
    return viewer.worldToClient(point);
  }

  var x = point.y;
  var y = point.x;

  var loadOptions;
  var bounds;

  if (viewer.model.getData().isPdf) {
    loadOptions = Autodesk.Viewing.PDFUtils.getLeafletLoadOptions(viewer);
    bounds = Autodesk.Viewing.PDFUtils.getLeafletBoundingBox(viewer);
  } else {
    var modelData = viewer.model.getData();
    loadOptions = modelData.loadOptions.loadOptions;
    bounds = modelData.bbox;
  }var _loadOptions2 =

  loadOptions,texWidth = _loadOptions2.texWidth,texHeight = _loadOptions2.texHeight;

  var maxLevel = computeMaxLevel(texWidth, texHeight);
  var scale = Math.pow(2, maxLevel);
  x *= scale;
  y *= scale;

  // https://jira.autodesk.com/browse/BLMV-2853
  // In case that the DPI of the current document is different than the DPI of the document where the pushpin has originally created (or edited)
  // We need to scale the ratio back in order that the pushpin will appear in the same place.
  var originalDocumentWidth = originalDocumentResolution && originalDocumentResolution[0] || texWidth;
  var dpiCorrection = texWidth / originalDocumentWidth;

  var wx = x / (texWidth / dpiCorrection) * bounds.size().x;
  var wy = y / (texHeight / dpiCorrection) * bounds.size().y;

  var worldPos = new THREE.Vector3(bounds.min.x + wx, bounds.max.y + wy, 0);

  if (viewer.model.getData().isPdf) {
    Autodesk.Viewing.PDFUtils.leafletToPdfWorld(viewer, worldPos);
  }

  return viewer.impl.worldToClient(worldPos);
}

// Used for saving pushpins in the backend like they were created in Leaflet, instead of PDF.
function convertPdfToLeaflet(viewer, itemData) {
  var p = Autodesk.Viewing.PDFUtils.pdfToLeafletWorld(viewer, new THREE.Vector3().copy(itemData.position));
  itemData.position = { x: p.y - 1, y: p.x, z: 0 }; // x & y are swapped for some reason. Can't change it now for backward compatibility.
}

/***/ }),

/***/ "./extensions/Pushpins/PushPins2D/PushPinBillboardTool2D.js":
/*!******************************************************************!*\
  !*** ./extensions/Pushpins/PushPins2D/PushPinBillboardTool2D.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PushPinBillboardTool2D; });
/* harmony import */ var _PushPinLabel_PushPinBillboardLabel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PushPinLabel/PushPinBillboardLabel */ "./extensions/Pushpins/PushPinLabel/PushPinBillboardLabel.js");
/* harmony import */ var _PushPinUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../PushPinUtils */ "./extensions/Pushpins/PushPinUtils.js");
/* harmony import */ var _PushPinConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../PushPinConstants */ "./extensions/Pushpins/PushPinConstants.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var

PushPinBillboardTool2D = /*#__PURE__*/function () {
  function PushPinBillboardTool2D(viewer) {_classCallCheck(this, PushPinBillboardTool2D);
    this.names = ['pushpinBillboard2D'];

    this.viewer = viewer;
    this.active = false;

    this.pushpins = [];
    this.selectedPushpin = null;
    this.dirty = false;
    this.camera = this.viewer.navigation.getCamera();
    this.curCameraZ = 0;
    this.curCameraRotationZ = 0;
  }_createClass(PushPinBillboardTool2D, [{ key: "getNames", value: function getNames()

    {
      return this.names;
    } }, { key: "getName", value: function getName()

    {
      return this.names[0];
    } }, { key: "isActive", value: function isActive()

    {
      return this.active;
    } }, { key: "activate", value: function activate(

    name) {var _this = this;
      if (name === this.getName()) {
        this.active = true;

        this.onCameraChangeBinded = function (e) {return _this.onCameraChange(e);};
        this.handleResizeBinded = function (e) {return _this.handleResize(e);};

        this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);
        this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.handleResizeBinded);

        this.createMarkerContainer();
      }
    } }, { key: "deactivate", value: function deactivate(

    name) {
      if (name === this.getName()) {
        this.active = false;

        this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);
        this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.handleResizeBinded);
      }
    } }, { key: "onCameraChange", value: function onCameraChange(

    e) {
      if (e.camera.position.z.toPrecision(5) !== this.curCameraZ.toPrecision(5) || e.camera.rotation.z.toPrecision(5) !== this.curCameraRotationZ.toPrecision(5)) {
        this.updatePushpinsProjection();
        this.curCameraZ = e.camera.position.z;
        this.curCameraRotationZ = e.camera.rotation.z;
      } else {
        this.updateContainerProjection();
      }
    } }, { key: "createMarkerContainer", value: function createMarkerContainer()

    {
      if (!this.pushpinContainer) {
        this.pushpinContainer = this.viewer.appendOrderedElementToViewer('pushpin-container');
        this.pushpinContainer.className = 'pushpin-container';
        this.pushpinContainer.position = new THREE.Vector3();
      }
    } }, { key: "project", value: function project(

    pushpin) {
      var position = pushpin.marker.intersectPoint;
      var containerBounds = this.viewer.navigation.getScreenViewport();
      var p = new THREE.Vector3().copy(position);

      var matrix = new THREE.Matrix4();

      matrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);

      p.applyProjection(matrix);

      return new THREE.Vector3(
      Math.round((p.x + 1) / 2 * containerBounds.width),
      Math.round((-p.y + 1) / 2 * containerBounds.height),
      p.z);

    } }, { key: "unproject", value: function unproject(

    position) {
      var containerBounds = this.viewer.navigation.getScreenViewport();
      var p = new THREE.Vector3();

      p.x = position.x / containerBounds.width * 2 - 1;
      p.y = -(position.y / containerBounds.height * 2 - 1);
      p.z = position.z;
      p.unproject(this.camera);

      return p;
    } }, { key: "initNewPushpin", value: function initNewPushpin(

    item) {
      if (this.viewer.model.getData().isLeaflet) {
        this.convertLeafletPosition(item);

        // https://jira.autodesk.com/browse/BLMV-2918
        // Update originalDocumentResolution when saving / updating a pushpin, in order to make sure that the pushpin will
        // maintain the same position for different DPIs of the same document.
        var modelData = this.viewer.model.getData();
        var options = modelData.loadOptions.loadOptions;
        item.setOriginalDocumentResolution([options.texWidth, options.texHeight]);
      } else {
        item.intersectPoint = item.data.position;
      }

      this.pushpins.push(item);

      this.createMarker(item);

      item.draggable ? this.enableDragging(item) : this.disableDragging(item);
      item.visible ? this.showMarker(item.marker) : this.hideMarker(item.marker);
    } }, { key: "createPushpin", value: function createPushpin(

    item) {
      this.initNewPushpin(item);
      this.selectPushpin(item);

      return Promise.resolve();
    } }, { key: "convertLeafletPosition", value: function convertLeafletPosition(

    item) {
      var worldPos = Object(_PushPinUtils__WEBPACK_IMPORTED_MODULE_1__["applyPdfWorldScaling"])(this.viewer, item.data);
      item.intersectPoint = { x: worldPos.x, y: worldPos.y, z: worldPos.z };
    } }, { key: "loadPushpin", value: function loadPushpin(

    item) {
      this.initNewPushpin(item);

      return Promise.resolve();
    } }, { key: "createMarker", value: function createMarker(

    pushpin) {
      var marker = document.createElement('div');

      var className = pushpin.data.type === 'rfis' ? 'rfi-billboard-marker' : 'pushpin-billboard-marker';

      marker.classList.add(className);
      marker.style.backgroundColor = _PushPinConstants__WEBPACK_IMPORTED_MODULE_2__["statusHexValues"][pushpin.data.status];
      marker.style.boxShadow = '0px 1px 6px rgba(0, 0, 0, 0.6)';

      this.pushpinContainer.appendChild(marker);

      marker.id = pushpin.data.id;
      marker.intersectPoint = pushpin.intersectPoint;

      pushpin.marker = marker;
      this.setMarkerPosition(pushpin);

      // first pushpin
      if (this.pushpins.length === 1) {
        this.setPushpinContainerPosition(pushpin);
      } else {
        var newPosX = pushpin.marker.position.x - this.pushpinContainer.position.x;
        var newPosY = pushpin.marker.position.y - this.pushpinContainer.position.y;
        pushpin.marker.style.transform = "translate(".concat(newPosX, "px, ").concat(newPosY, "px)");
      }
    } }, { key: "removePushpin", value: function removePushpin(

    pushpin) {var _this2 = this;
      this.pushpins = this.pushpins.filter(function (curPushpin) {
        if (_this2.selectedPushpin && _this2.selectedPushpin.data.id === pushpin.data.id) {
          _this2.selectedPushpin = null;
        }

        return curPushpin.data.id !== pushpin.data.id;
      });

      this.destroyMarker(pushpin);
    } }, { key: "removeAll", value: function removeAll()

    {var _this3 = this;
      this.pushpins.forEach(function (pushpin) {
        _this3.removePushpin(pushpin);
      });
    } }, { key: "destroyMarker", value: function destroyMarker(

    pushpin) {
      this.destroyLabel(pushpin);
      this.pushpinContainer.removeChild(pushpin.marker);
      pushpin.marker = undefined;
    } }, { key: "destroyLabel", value: function destroyLabel(

    pushpin) {
      if (pushpin.label) {
        pushpin.marker.removeChild(pushpin.label.container);
        pushpin.label = undefined;
      }
    } }, { key: "setPushpinContainerPosition", value: function setPushpinContainerPosition(

    pushpin) {
      var xTranslate = pushpin.marker.position.x - _PushPinConstants__WEBPACK_IMPORTED_MODULE_2__["markerOffsets"].markerOffsetWidth / 2;
      var yTranslate = pushpin.marker.position.y - _PushPinConstants__WEBPACK_IMPORTED_MODULE_2__["markerOffsets"].markerOffsetWidth / 2;

      this.pushpinContainer.initPos = pushpin.intersectPoint;
      this.pushpinContainer.position.x = pushpin.marker.position.x;
      this.pushpinContainer.position.y = pushpin.marker.position.y;
      this.pushpinContainer.style.transform = "translate(".concat(xTranslate, "px, ").concat(yTranslate, "px)");
    } }, { key: "setMarkerPosition", value: function setMarkerPosition(

    pushpin) {
      pushpin.marker.position = this.project(pushpin);
    } }, { key: "updateStyle", value: function updateStyle(

    status, size, hex) {
      _PushPinConstants__WEBPACK_IMPORTED_MODULE_2__["statusHexValues"][status] = hex;
      this.dirty = true;
    } }, { key: "updateContainerProjection", value: function updateContainerProjection()

    {var _this4 = this;
      if (this.pushpins.length > 0) {
        var newPosition = { marker: { intersectPoint: this.pushpinContainer.initPos } };
        var updatedPosition = this.pushpinContainer.position = this.project(newPosition);
        var offsetWidth = _PushPinConstants__WEBPACK_IMPORTED_MODULE_2__["markerOffsets"].markerOffsetWidth;

        var xTranslate = updatedPosition.x - offsetWidth / 2;
        var yTranslate = updatedPosition.y - offsetWidth / 2;

        this.pushpinContainer.style.transform = "translate(".concat(xTranslate, "px, ").concat(yTranslate, "px)");
      }

      // Update the DOM
      this.pushpins.forEach(function (pushpin) {
        _this4.updatePushpin(pushpin);
      });

      this.dirty = false;
    } }, { key: "updatePushpinsProjection", value: function updatePushpinsProjection()

    {var _this5 = this;
      this.redraw = true;
      this.pushpins.forEach(function (pushpin) {
        _this5.setMarkerPosition(pushpin);
      });

      this.pushpins.forEach(function (pushpin) {
        if (_this5.redraw) {
          _this5.setPushpinContainerPosition(pushpin);
          _this5.redraw = false;
        }

        var xPos = pushpin.marker.position.x - _this5.pushpinContainer.position.x;
        var yPos = pushpin.marker.position.y - _this5.pushpinContainer.position.y;
        pushpin.marker.style.transform = "translate(".concat(xPos, "px, ").concat(yPos, "px)");

        _this5.updatePushpin(pushpin);
      });

      this.dirty = false;
    } }, { key: "updatePushpin", value: function updatePushpin(

    pushpin) {
      if (this.dirty) {
        if (pushpin.label) {
          pushpin.label.update(pushpin.data.label);
        }

        pushpin.draggable ? this.enableDragging(pushpin) : this.disableDragging(pushpin);
        pushpin.marker.style.backgroundColor = _PushPinConstants__WEBPACK_IMPORTED_MODULE_2__["statusHexValues"][pushpin.data.status];
        pushpin.visible ? this.showMarker(pushpin.marker) : this.hideMarker(pushpin.marker);
      }
    } }, { key: "setDirty", value: function setDirty()

    {
      this.dirty = true;
    } }, { key: "selectPushpin", value: function selectPushpin(

    pushpin) {
      this.deselect();
      this.viewer.clearSelection();

      pushpin.label = new _PushPinLabel_PushPinBillboardLabel__WEBPACK_IMPORTED_MODULE_0__["default"](pushpin.marker, pushpin.data.label);
      pushpin.marker.classList.add('selected');

      this.selectedPushpin = pushpin;
      pushpin.draggable ? this.enableDragging(pushpin) : this.disableDragging(pushpin);
    } }, { key: "deselect", value: function deselect()

    {
      if (this.selectedPushpin) {
        this.destroyLabel(this.selectedPushpin);
        this.selectedPushpin.marker.style.pointerEvents = 'none';
        this.selectedPushpin.marker.classList.remove('selected');
        this.selectedPushpin = null;
      }
    } }, { key: "enableDragging", value: function enableDragging(

    item) {
      if (this.selectedPushpin && this.selectedPushpin.data.id === item.data.id) {
        item.marker.style.pointerEvents = 'auto';
      }

      item.marker.style.backgroundImage = _PushPinConstants__WEBPACK_IMPORTED_MODULE_2__["moveableIcon"];
    } }, { key: "disableDragging", value: function disableDragging(

    item) {
      var selectedItem = item || this.selectedPushpin;

      selectedItem.marker.style.pointerEvents = 'none';
      selectedItem.marker.style.backgroundImage = 'none';
      selectedItem.draggable = false;
    } }, { key: "showMarker", value: function showMarker(

    marker) {
      marker.style.display = '';
    } }, { key: "hideMarker", value: function hideMarker(

    marker) {
      marker.style.display = 'none';
    } }, { key: "showMarkers", value: function showMarkers()

    {var _this6 = this;
      this.pushpins.forEach(function (pushpin) {
        pushpin.visible ? _this6.showMarker(pushpin.marker) : _this6.hideMarker(pushpin.marker);
      });
    } }, { key: "hideMarkers", value: function hideMarkers()

    {var _this7 = this;
      this.pushpins.forEach(function (pushpin) {
        _this7.hideMarker(pushpin.marker);
      });

      if (this.selectedPushpin) {
        this.destroyLabel(this.selectedPushpin);
      }
    } }, { key: "handleButtonDown", value: function handleButtonDown(


    event, button) {
      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      return false;
    } }, { key: "handleResize", value: function handleResize()

    {var _this8 = this;
      setTimeout(function () {
        _this8.updatePushpinsProjection();
      }, 1);
    } }]);return PushPinBillboardTool2D;}();


var namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');

namespace.PushPinBillboardTool2D = PushPinBillboardTool2D;

/***/ }),

/***/ "./extensions/Pushpins/PushPins2D/RenderHandler2D.js":
/*!***********************************************************!*\
  !*** ./extensions/Pushpins/PushPins2D/RenderHandler2D.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderHandler2D; });
/* harmony import */ var _PushPins2D_PushPinBillboardTool2D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PushPins2D/PushPinBillboardTool2D */ "./extensions/Pushpins/PushPins2D/PushPinBillboardTool2D.js");
/* harmony import */ var _PushPinInputHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../PushPinInputHandler */ "./extensions/Pushpins/PushPinInputHandler.js");
/* harmony import */ var _PushPinUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../PushPinUtils */ "./extensions/Pushpins/PushPinUtils.js");
/* harmony import */ var _PushPinEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../PushPinEvents */ "./extensions/Pushpins/PushPinEvents.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var

RenderHandler2D = /*#__PURE__*/function () {
  function RenderHandler2D(viewerApi, pushPinManager) {var _this = this;_classCallCheck(this, RenderHandler2D);
    this.viewer = viewerApi;
    this.pushPinManager = pushPinManager;
    this.pushpinDirty = false;
    this.selectedItem = null;

    this.onSelectedChangedBind = function (e) {return _this.onSelectedChanged(e);};
    this.onRemoveBind = function (e) {return _this.onRemove(e);};
    this.onRemoveAllBind = function (e) {return _this.onRemoveAll(e);};
    this.onModifyBind = function (e) {return _this.onModify(e);};
    this.onUpdateBind = function (e) {return _this.onUpdate(e);};
    this.createBind = function (e) {return _this.create(e);};
    this.onVisibilityChangedBind = function (e) {return _this.onVisibilityChanged(e);};
  }_createClass(RenderHandler2D, [{ key: "register", value: function register()

    {
      this.pushpinBillboardTool = new _PushPins2D_PushPinBillboardTool2D__WEBPACK_IMPORTED_MODULE_0__["default"](this.viewer);
      this.viewer.toolController.registerTool(this.pushpinBillboardTool);
    } }, { key: "deregister", value: function deregister()

    {
      if (this.pushpinBillboardTool) {
        this.viewer.toolController.deregisterTool(this.pushpinBillboardTool);
        this.pushpinBillboardTool = null;
      }
    } }, { key: "activate", value: function activate()

    {
      if (!this.pushpinBillboardTool.isActive()) {
        this.viewer.toolController.activateTool('pushpinBillboard2D');
      }

      this.inputHandler = new _PushPinInputHandler__WEBPACK_IMPORTED_MODULE_1__["default"](this);

      this.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_3__["PUSHPIN_EVENTS"].PUSH_PIN_SELECTED_EVENT, this.onSelectedChangedBind);
      this.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_3__["PUSHPIN_EVENTS"].PUSH_PIN_REMOVED_EVENT, this.onRemoveBind);
      this.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_3__["PUSHPIN_EVENTS"].PUSH_PIN_REMOVE_ALL_EVENT, this.onRemoveAllBind);
      this.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_3__["PUSHPIN_EVENTS"].PUSH_PIN_MODIFY_EVENT, this.onModifyBind);
      this.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_3__["PUSHPIN_EVENTS"].PUSH_PIN_UPDATE_EVENT, this.onUpdateBind);
      this.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_3__["PUSHPIN_EVENTS"].PUSH_PIN_VISIBILITY_EVENT, this.onVisibilityChangedBind);
      this.pushPinManager.setCreateFunction(this.createBind);

      return true;
    } }, { key: "deactivate", value: function deactivate()

    {
      if (this.pushpinBillboardTool.isActive()) {
        this.viewer.toolController.deactivateTool('pushpinBillboard2D');
      }

      this.inputHandler.detach();

      this.pushPinManager.removeEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_3__["PUSHPIN_EVENTS"].PUSH_PIN_SELECTED_EVENT, this.onSelectedChangedBind);
      this.pushPinManager.removeEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_3__["PUSHPIN_EVENTS"].PUSH_PIN_REMOVED_EVENT, this.onRemoveBind);
      this.pushPinManager.removeEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_3__["PUSHPIN_EVENTS"].PUSH_PIN_REMOVE_ALL_EVENT, this.onRemoveAllBind);
      this.pushPinManager.removeEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_3__["PUSHPIN_EVENTS"].PUSH_PIN_MODIFY_EVENT, this.onModifyBind);
      this.pushPinManager.removeEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_3__["PUSHPIN_EVENTS"].PUSH_PIN_UPDATE_EVENT, this.onUpdateBind);
      this.pushPinManager.removeEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_3__["PUSHPIN_EVENTS"].PUSH_PIN_VISIBILITY_EVENT, this.onVisibilityChangedBind);
      this.pushPinManager.removeCreateFunction(this.createBind);

    } }, { key: "setPushpinDirty", value: function setPushpinDirty()

    {
      this.pushpinDirty = true;
    } }, { key: "onSelectedChanged", value: function onSelectedChanged(

    event) {
      if (event.value) {
        this.selectedItem = event.value;

        if (!this.selectedItem.marker) {
          this.create(this.selectedItem);
        }

        this.pushpinBillboardTool.selectPushpin(this.selectedItem);
        this.focusCameraOnSelectedItem(this.selectedItem);

        if (this.selectedItem.draggable) {
          this.enableItemDragging(this.selectedItem);
        }

        this.viewer.dispatchEvent({ type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_3__["PUSHPIN_EVENTS"].PUSH_PIN_SELECTED_EVENT });
      } else {
        this.deselectItem();
        this.pushpinBillboardTool.deselect();
      }

      this.setPushpinDirty();
    } }, { key: "deselectItem", value: function deselectItem()

    {
      this.selectedItem = null;
      this.inputHandler.detach();
    } }, { key: "onRemove", value: function onRemove(

    event) {
      if (this.selectedItem && event.value.data.id === this.selectedItem.data.id) {
        this.deselectItem();
      }

      if (event.value && event.value.marker) {
        this.pushpinBillboardTool.removePushpin(event.value);
      }
    } }, { key: "onRemoveAll", value: function onRemoveAll()

    {
      this.deselectItem();
      this.pushpinBillboardTool.removeAll();
    } }, { key: "onModify", value: function onModify()

    {
      this.pushpinDirty = true;
    } }, { key: "onVisibilityChanged", value: function onVisibilityChanged()

    {
      this.pushpinBillboardTool.showMarkers();
    } }, { key: "onUpdate", value: function onUpdate()

    {var _this2 = this;
      setTimeout(function () {
        _this2.setPushpinDirty();

        // it could happen that the extension was removed in the meantime
        _this2.pushpinBillboardTool && _this2.pushpinBillboardTool.setDirty();
        var selectedItem = _this2.pushPinManager ? _this2.pushPinManager.getSelectedItem() : null;

        if (!selectedItem) {
          return;
        }

        selectedItem.draggable && selectedItem.marker ?
        _this2.enableItemDragging(selectedItem) :
        _this2.disableItemDragging(selectedItem);
      }, 1);
    } }, { key: "enableItemDragging", value: function enableItemDragging(

    item) {
      this.pushpinBillboardTool.enableDragging(item);
      this.inputHandler.attachTo(item.marker);
    } }, { key: "disableItemDragging", value: function disableItemDragging(

    item) {
      this.pushpinBillboardTool.disableDragging(item);
      this.inputHandler.detach();
    } }, { key: "create", value: function create(

    item) {
      // iOS have a special case where they already have the UUID, so we act like we are re-selecting an existing item
      return this.createRenderItem(item, Autodesk.Viewing.isIOSDevice());
    } }, { key: "createRenderItem", value: function createRenderItem(

    item, reselect) {
      // Make sure it's a uuid and not a growing counter
      var isLoaded = item.data.id.length > 20;

      this.pushpinBillboardTool.deselect();

      var promise;
      if (isLoaded && !reselect) {
        promise = this.pushpinBillboardTool.loadPushpin(item);
      } else {
        promise = this.pushpinBillboardTool.createPushpin(item);
        this.pushPinManager.selectOne(item.data.id);
      }

      return promise;
    } }, { key: "updatePattern", value: function updatePattern(

    status, size, hex) {
      this.pushpinBillboardTool.updateStyle(status, size, hex);

      this.setPushpinDirty();
    } }, { key: "focusCameraOnSelectedItem", value: function focusCameraOnSelectedItem(

    item) {
      if (item.marker) {
        var padding = 0.2;

        var modelBounds = this.viewer.utilities.getBoundingBox(true);
        var modelWidth = (modelBounds.max.x - modelBounds.min.x) * padding;
        var modelHeight = (modelBounds.max.y - modelBounds.min.y) * padding;

        var min = new THREE.Vector3(item.marker.intersectPoint.x - modelWidth, item.marker.intersectPoint.y - modelHeight, 0);
        var max = new THREE.Vector3(item.marker.intersectPoint.x + modelWidth, item.marker.intersectPoint.y + modelHeight, 0);
        var bounds = new THREE.Box3(min, max);

        this.viewer.navigation.fitBounds(false, bounds, true);
      }
    } }, { key: "render", value: function render()

    {var _this3 = this;
      if (!this.pushPinManager || !this.viewer.model) {
        return;
      }

      this.pushPinManager.items().reverse().forEach(function (item) {
        if (!item.marker) {
          _this3.createRenderItem(item, false);
        }
      });

      if (this.pushpinDirty) {
        this.pushpinBillboardTool.updateContainerProjection();
        this.pushpinDirty = false;
      }
    } }, { key: "findIntersections", value: function findIntersections(

    event) {
      var mouseX = event.clientX;
      var mouseY = event.clientY;

      var hitItem = null;

      this.pushPinManager.items().some(function (item) {
        if (item.selectable && item.marker) {
          var bb = item.marker.getBoundingClientRect();
          if (mouseX > bb.left && mouseX < bb.left + bb.width && mouseY > bb.top && mouseY < bb.top + bb.height) {
            hitItem = item;
            return true;
          }
        }
        return false;
      });

      return hitItem;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    e) {
      function mouseCoords(ev) {
        if (ev.pageX || ev.pageY) {
          return { x: ev.pageX, y: ev.pageY };
        }

        return {
          x: ev.clientX + document.body.scrollLeft - document.body.clientLeft,
          y: ev.clientY + document.body.scrollTop - document.body.clientTop };

      }

      if (this.selectedItem.marker && this.selectedItem.marker.startDragging) {
        // only on first mouse movement
        if (!this.newX) {
          this.selectedItem.marker.style.transform = 'translate(0px, 0px)';
        }

        var mousePos = mouseCoords(e);

        this.newX = mousePos.x - this.mouseOffset.x;
        this.newY = mousePos.y - this.mouseOffset.y;

        // Check left, top, right, bottom
        var containerBounds = this.viewer.navigation.getScreenViewport();
        var wi = this.selectedItem.marker.clientWidth;
        var hi = this.selectedItem.marker.clientHeight;

        if (this.newX < 5) {
          this.newX = 0;
        }
        if (this.newY < 5) {
          this.newY = 0;
        }
        if (containerBounds.width - 5 < this.newX + wi) {
          this.newX = containerBounds.width - wi;
        }
        if (containerBounds.height - 5 < this.newY + hi) {
          this.newY = containerBounds.height - hi;
        }

        var containerPosX = this.pushpinBillboardTool.pushpinContainer.position.x;
        var containerPosY = this.pushpinBillboardTool.pushpinContainer.position.y;

        this.selectedItem.marker.style.left = "".concat(this.newX - containerPosX, "px");
        this.selectedItem.marker.style.top = "".concat(this.newY - containerPosY, "px");

        this.selectedItem.marker.dragging = true;
      }
    } }, { key: "handleMouseUp", value: function handleMouseUp(

    e) {var _this4 = this;
      if (this.selectedItem.marker) {
        if (this.selectedItem.marker.dragging) {
          var containerPosX = this.pushpinBillboardTool.pushpinContainer.position.x;
          var containerPosY = this.pushpinBillboardTool.pushpinContainer.position.y;

          this.selectedItem.marker.style.transform = "translate(".concat(this.newX - containerPosX, "px, ").concat(this.newY - containerPosY, "px)");

          var result = Object(_PushPinUtils__WEBPACK_IMPORTED_MODULE_2__["clientToWorld"])(this.viewer, this.newX, this.newY);

          this.selectedItem.data.position = { x: result.x, y: result.y, z: result.z };

          this.pushPinManager.generateThumbnail(this.selectedItem).then(function (thumbnail) {var _this4$selectedItem$d =
            _this4.selectedItem.data.position,x = _this4$selectedItem$d.x,y = _this4$selectedItem$d.y,z = _this4$selectedItem$d.z; // Backup position.

            if (_this4.viewer.model.getData().isPdf) {
              Object(_PushPinUtils__WEBPACK_IMPORTED_MODULE_2__["convertPdfToLeaflet"])(_this4.viewer, _this4.selectedItem.data);
            }

            _this4.pushPinManager.fireEvent({ type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_3__["PUSHPIN_EVENTS"].PUSH_PIN_MODIFY_EVENT, value: _this4.selectedItem, thumbnail: thumbnail });

            _this4.selectedItem.data.position = { x: x, y: y, z: z }; // Restore position.
          });

          this.pushpinBillboardTool.removeAll();
          this.render();
          this.pushpinBillboardTool.selectPushpin(this.pushPinManager.selectedItem);
          if (this.selectedItem.draggable) {
            this.enableItemDragging(this.selectedItem);
          }
        } else {
          this.selectedItem.marker.startDragging = false;
        }
      }
    } }, { key: "handleMouseDown", value: function handleMouseDown(

    event) {
      function getOffset(e) {
        var left = 0;
        var top = 0;

        while (e.offsetParent) {
          left += e.offsetLeft;
          top += e.offsetTop;
          e = e.offsetParent;
        }

        left += e.offsetLeft;
        top += e.offsetTop;
        return { x: left, y: top };
      }

      if (this.selectedItem.marker) {
        if (event.target.tagName.toLowerCase() === 'textarea') {
          return;
        }

        this.mouseOffset = getOffset(this.viewer.container);

        this.newX = null;
        this.newY = null;

        this.selectedItem.marker.startDragging = true;
      }
    } }]);return RenderHandler2D;}();

/***/ }),

/***/ "./extensions/Pushpins/PushPins3D/PushPinBillboardTool3D.js":
/*!******************************************************************!*\
  !*** ./extensions/Pushpins/PushPins3D/PushPinBillboardTool3D.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PushPinBillboardTool3D; });
/* harmony import */ var _PushPinLabel_PushPinBillboardLabel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PushPinLabel/PushPinBillboardLabel */ "./extensions/Pushpins/PushPinLabel/PushPinBillboardLabel.js");
/* harmony import */ var _PushPinConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../PushPinConstants */ "./extensions/Pushpins/PushPinConstants.js");
/* harmony import */ var _PushPins3D_PushPinViewerState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../PushPins3D/PushPinViewerState */ "./extensions/Pushpins/PushPins3D/PushPinViewerState.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var

PushPinBillboardTool3D = /*#__PURE__*/function () {
  function PushPinBillboardTool3D(viewer) {var _this = this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, PushPinBillboardTool3D);
    this.names = ['pushpinBillboard3D'];

    this.viewer = viewer;

    this.active = false;

    this.pushpins = [];
    this.selectedPushpin = null;
    this.dirty = false;
    this.camera = this.viewer.navigation.getCamera();

    var raycastLimitPerSecond = 200; // execute at most once every x milliseconds.
    this.maxMsPerRayCastCycle = 20;
    this.updateTimestamp = 0;

    if (!options.disableOcclusionTest) {
      // Ray-casts for occlusion tests. The only purpose is to change the opacity of occluded PushPins, at the costs of:
      //  - Memory: Loading the externalID file (may be huge for large projects)
      //  - Performance: Repeatedly firing lots of raytests and worker tasks (#PushPins separate queries per camera change)
      this.raycastThrottle = this.throttle(function () {
        _this.continueRayCasts();
      }, raycastLimitPerSecond);
    } else {
      // Bypass raycasts for occlusion checks.
      this.raycastThrottle = function () {};
    }
  }_createClass(PushPinBillboardTool3D, [{ key: "continueRayCasts", value: function continueRayCasts()

    {
      var stamp = performance.now();
      var i = 0;
      for (; i < this.pushpins.length; i++) {
        var pushpin = this.pushpins[i];
        if (!pushpin.visible) {
          continue;
        }
        if (pushpin.updateTimestamp !== this.updateTimestamp) {
          pushpin.updateTimestamp = this.updateTimestamp;
          this.castRay(pushpin);
          if (performance.now() > stamp + this.maxMsPerRayCastCycle) {
            break;
          }
        }
      }

      // Make sure that we continue if we couldn't do them all
      if (i < this.pushpins.length) {
        this.raycastThrottle();
      }
    } }, { key: "getNames", value: function getNames()

    {
      return this.names;
    } }, { key: "getName", value: function getName()

    {
      return this.names[0];
    } }, { key: "isActive", value: function isActive()

    {
      return this.active;
    } }, { key: "activate", value: function activate(

    name) {var _this2 = this;
      if (name === this.getName()) {
        this.active = true;

        this.onCameraChangeBinded = function (e) {return _this2.onCameraChange(e);};
        this.handleResizeBinded = function (e) {return _this2.handleResize(e);};

        this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);
        this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.handleResizeBinded);
      }
    } }, { key: "throttle", value: function throttle(

    callback, wait) {var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;
      var timeout = null;
      var callbackArgs = null;

      var later = function later() {
        timeout = null;
        callback.apply(context, callbackArgs);
      };

      return function () {
        if (!timeout) {
          callbackArgs = arguments;
          timeout = setTimeout(later, wait);
        }
      };
    } }, { key: "deactivate", value: function deactivate(

    name) {
      if (name === this.getName()) {
        this.active = false;

        this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);
        this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.handleResizeBinded);
      }
    } }, { key: "onCameraChange", value: function onCameraChange()

    {
      this.updatePushpins();
    } }, { key: "project", value: function project(

    pushpin) {
      var position = pushpin.marker.intersectPoint;
      var containerBounds = this.viewer.navigation.getScreenViewport();
      var p = new THREE.Vector3().copy(position);

      var matrix = new THREE.Matrix4();
      var frustum = new THREE.Frustum();

      matrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);

      // We don't change visibility if pushpin is hidden anyway
      if (pushpin.visible) {
        frustum.setFromMatrix(matrix);
        !frustum.containsPoint(p) ? this.hideMarker(pushpin.marker) : this.showMarker(pushpin.marker);
      }

      p.applyProjection(matrix);

      return new THREE.Vector3(
      Math.round((p.x + 1) / 2 * containerBounds.width),
      Math.round((-p.y + 1) / 2 * containerBounds.height),
      p.z);

    } }, { key: "unproject", value: function unproject(

    position) {
      var containerBounds = this.viewer.navigation.getScreenViewport();
      var p = new THREE.Vector3();

      p.x = position.x / containerBounds.width * 2 - 1;
      p.y = -(position.y / containerBounds.height * 2 - 1);
      p.z = position.z;
      p.unproject(this.camera);

      return p;
    } }, { key: "initNewPushpin", value: function initNewPushpin(

    item) {
      item.intersectPoint = item.data.position;

      this.pushpins.push(item);

      this.createMarker(item);

      item.draggable ? this.enableDragging(item) : this.disableDragging(item);
      item.visible ? this.showMarker(item.marker) : this.hideMarker(item.marker);
    } }, { key: "fetchExternalId", value: function fetchExternalId(

    model, dbId, callback) {var _this3 = this;
      return new Promise(function (resolve, reject) {
        var onSuccessCallback = function onSuccessCallback(props) {
          var externalId = props.externalId;

          // For some files (i.e. STEP) the externalId is an array that contains the whole hierarchy of the element
          // Since we need only a string in the end we take the last element (the hierarchy is concatenated anyway,
          // so each element contains the whole information needed to identify it)
          if (externalId.startsWith('[') && externalId.endsWith(']')) {
            try {
              var parsedExternalId = JSON.parse(externalId);
              if (Array.isArray(parsedExternalId)) {
                externalId = parsedExternalId[parsedExternalId.length - 1];
              }
            } catch (e) {
              console.error('Error ' + e + ' parsing externalId ', externalId);
            }
          }

          if (model.getData().loadOptions.fileExt === 'ifc') {
            var ifcId = props.properties.find(function (el) {return el.displayName === 'IfcGUID' || el.displayName === 'GLOBALID' && el.displayCategory === 'IFC';});
            if (ifcId) {
              externalId = ifcId.displayValue;
            } else {// If there's no IFC id, look at the parent
              var parentDbId = props.properties.find(function (el) {return el.displayName === 'parent' && el.displayValue > -1;});
              if (parentDbId) {
                resolve(_this3.fetchExternalId(model, parentDbId.displayValue, callback));
                return;
              }
            }
          }
          callback(externalId);
          resolve();
        };

        var onErrorCallback = function onErrorCallback(status, message, data) {
          Autodesk.Viewing.Private.logger.warn(message);
          resolve(); // Log the message but don't fail
        };

        model.getProperties2(dbId, onSuccessCallback, onErrorCallback, { needsExternalId: true });
      });
    } }, { key: "createPushpin", value: function createPushpin(

    item) {
      this.initNewPushpin(item);

      var globalOffset = this.viewer.model ? this.viewer.model.getData().globalOffset : null;
      item.setViewerState(Object(_PushPins3D_PushPinViewerState__WEBPACK_IMPORTED_MODULE_2__["generateMetadata"])(this.viewer.getState(), globalOffset));

      this.selectPushpin(item);

      var vpVec = this.viewer.impl.clientToViewport(item.marker.position.x, item.marker.position.y);
      var res = this.viewer.impl.castRayViewport(vpVec, false);

      if (res) {
        item.setObjectId(res.dbId);
        item.setObjectData(res);

        var model = item.findModel(this.viewer);
        if (!model) {
          console.error('Failed to assign externalId: The model for this PushPin is not loaded.');
          return Promise.resolve();
        }

        return this.fetchExternalId(model, res.dbId, function (externalId) {return item.setExternalId(externalId);});
      } else {
        return Promise.resolve();
      }
    } }, { key: "loadPushpin", value: function loadPushpin(

    item) {
      this.initNewPushpin(item);

      return Promise.resolve();
    } }, { key: "createMarker", value: function createMarker(

    pushpin) {
      var marker = document.createElement('div');
      pushpin.marker = marker;

      marker.id = pushpin.data.id;
      marker.intersectPoint = pushpin.intersectPoint;

      if (pushpin.hasPosition()) {
        var className = pushpin.data.type === 'rfis' ? 'rfi-billboard-marker' : 'pushpin-billboard-marker';

        marker.classList.add(className);
        marker.style.backgroundColor = _PushPinConstants__WEBPACK_IMPORTED_MODULE_1__["statusHexValues"][pushpin.data.status];

        this.viewer.container.appendChild(marker);

        this.setMarkerPosition(pushpin);

        var xTranslate = pushpin.marker.position.x - _PushPinConstants__WEBPACK_IMPORTED_MODULE_1__["markerOffsets"].markerOffsetWidth / 2;
        var yTranslate = pushpin.marker.position.y - _PushPinConstants__WEBPACK_IMPORTED_MODULE_1__["markerOffsets"].markerOffsetWidth / 2;

        pushpin.marker.style.transform = "translate(".concat(xTranslate, "px, ").concat(yTranslate, "px)");
      } else {
        // Imported issues (such as from BCF) can arrive without a position. They just store the camera state
        // In that case create a dummy marker (since the extension assumes it exists in many places) and don't 
        // add it to the viewer.container
        this.hideMarker(marker);
        pushpin.visible = false;
      }
    } }, { key: "removePushpin", value: function removePushpin(

    pushpin) {var _this4 = this;
      this.pushpins = this.pushpins.filter(function (curPushpin) {
        if (_this4.selectedPushpin && _this4.selectedPushpin.data.id === pushpin.data.id) {
          _this4.selectedPushpin = null;
        }

        return curPushpin.data.id !== pushpin.data.id;
      });

      this.destroyMarker(pushpin);
    } }, { key: "removeAll", value: function removeAll()

    {var _this5 = this;
      this.pushpins.forEach(function (pushpin) {
        _this5.removePushpin(pushpin);
      });
    } }, { key: "destroyMarker", value: function destroyMarker(

    pushpin) {
      this.destroyLabel(pushpin);
      this.viewer.container.removeChild(pushpin.marker);
      pushpin.marker = undefined;
    } }, { key: "destroyLabel", value: function destroyLabel(

    pushpin) {
      if (pushpin.label) {
        pushpin.marker.removeChild(pushpin.label.container);
        pushpin.label = undefined;
      }
    } }, { key: "setMarkerPosition", value: function setMarkerPosition(

    pushpin) {
      pushpin.marker.position = this.project(pushpin);
    } }, { key: "updateStyle", value: function updateStyle(

    status, size, hex) {
      _PushPinConstants__WEBPACK_IMPORTED_MODULE_1__["statusHexValues"][status] = hex;
      this.dirty = true;
    } }, { key: "castRay", value: function castRay(

    pushpin) {
      var objectId = parseInt(pushpin.data.objectId, 10);
      if (isNaN(objectId) || objectId === -1) {// no check needed
        return;
      }

      var vpVec = this.viewer.impl.clientToViewport(pushpin.marker.position.x, pushpin.marker.position.y);
      var res = this.viewer.impl.castRayViewport(vpVec, false);
      if (res && res.dbId) {
        if (pushpin.data.externalId) {
          return this.fetchExternalId(res.model, res.dbId, function (externalId) {
            // it could happen that the pushpin was removed in the meantime
            if (pushpin && pushpin.marker && pushpin.data) {
              pushpin.marker.style.opacity = externalId === pushpin.data.externalId ? '1.0' : '0.15';
            }
          });
        }
        if (pushpin.data.objectId && parseInt(pushpin.data.objectId, 10) !== -1) {
          pushpin.marker.style.opacity = res.dbId === parseInt(pushpin.data.objectId, 10) ? '1.0' : '0.15';
        }
      } else {// no object was hit
        pushpin.marker.style.opacity = '0.15';
      }
    } }, { key: "updatePushpins", value: function updatePushpins()

    {var _this6 = this;
      // Calc new position
      this.updateTimestamp++;
      this.raycastThrottle();

      this.pushpins.forEach(function (pushpin) {
        _this6.setMarkerPosition(pushpin);
      });

      // Update the DOM
      this.pushpins.forEach(function (pushpin) {
        var offsetWidth = pushpin.selected ? _PushPinConstants__WEBPACK_IMPORTED_MODULE_1__["markerOffsets"].selectedMarkerOffsetWidth : _PushPinConstants__WEBPACK_IMPORTED_MODULE_1__["markerOffsets"].markerOffsetWidth;

        var xTranslate = pushpin.marker.position.x - offsetWidth / 2;
        var yTranslate = pushpin.marker.position.y - offsetWidth / 2;

        pushpin.marker.style.transform = "translate(".concat(xTranslate, "px, ").concat(yTranslate, "px)");

        if (_this6.dirty) {
          if (pushpin.label) {
            pushpin.label.update(pushpin.data.label);
          }

          pushpin.draggable ? _this6.enableDragging(pushpin) : _this6.disableDragging(pushpin);
          pushpin.marker.style.backgroundColor = _PushPinConstants__WEBPACK_IMPORTED_MODULE_1__["statusHexValues"][pushpin.data.status];
          pushpin.visible ? _this6.showMarker(pushpin.marker) : _this6.hideMarker(pushpin.marker);
        }
      });

      this.dirty = false;
    } }, { key: "setDirty", value: function setDirty()

    {
      this.dirty = true;
    } }, { key: "selectPushpin", value: function selectPushpin(

    pushpin) {
      this.deselect();
      this.viewer.clearSelection();

      pushpin.label = new _PushPinLabel_PushPinBillboardLabel__WEBPACK_IMPORTED_MODULE_0__["default"](pushpin.marker, pushpin.data.label);
      pushpin.marker.classList.add('selected');

      this.selectedPushpin = pushpin;
    } }, { key: "deselect", value: function deselect()

    {
      if (this.selectedPushpin) {
        this.destroyLabel(this.selectedPushpin);
        this.selectedPushpin.marker.style.pointerEvents = 'none';
        this.selectedPushpin.marker.classList.remove('selected');
        this.selectedPushpin = null;
      }
    } }, { key: "enableDragging", value: function enableDragging(

    item) {
      if (this.selectedPushpin && this.selectedPushpin.data.id === item.data.id) {
        item.marker.style.pointerEvents = 'auto';
      }
      item.marker.style.backgroundImage = _PushPinConstants__WEBPACK_IMPORTED_MODULE_1__["moveableIcon"];
    } }, { key: "disableDragging", value: function disableDragging(

    item) {
      var selectedItem = item || this.selectedPushpin;

      selectedItem.marker.style.pointerEvents = 'none';
      selectedItem.marker.style.backgroundImage = 'none';
      selectedItem.draggable = false;
    } }, { key: "hideLabel", value: function hideLabel()

    {
      if (this.selectedPushpin) {
        this.selectedPushpin.label.hide();
      }
    } }, { key: "showMarker", value: function showMarker(

    marker) {
      marker.style.display = '';
    } }, { key: "hideMarker", value: function hideMarker(

    marker) {
      marker.style.display = 'none';
    } }, { key: "showMarkers", value: function showMarkers()

    {var _this7 = this;
      this.pushpins.forEach(function (pushpin) {
        pushpin.visible ? _this7.project(pushpin) : _this7.hideMarker(pushpin.marker);
      });
    } }, { key: "hideMarkers", value: function hideMarkers()

    {var _this8 = this;
      this.pushpins.forEach(function (pushpin) {
        _this8.hideMarker(pushpin.marker);
      });

      if (this.selectedPushpin) {
        this.destroyLabel(this.selectedPushpin);
      }
    } }, { key: "handleButtonDown", value: function handleButtonDown(


    event, button) {
      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      return false;
    } }, { key: "handleResize", value: function handleResize()

    {
      this.updatePushpins();
    } }]);return PushPinBillboardTool3D;}();


var namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');

namespace.PushPinBillboardTool3D = PushPinBillboardTool3D;

/***/ }),

/***/ "./extensions/Pushpins/PushPins3D/PushPinViewerState.js":
/*!**************************************************************!*\
  !*** ./extensions/Pushpins/PushPins3D/PushPinViewerState.js ***!
  \**************************************************************/
/*! exports provided: generateMetadata, restoreViewState, transformViewerState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateMetadata", function() { return generateMetadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "restoreViewState", function() { return restoreViewState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformViewerState", function() { return transformViewerState; });
var applyOffsetToCamera = function applyOffsetToCamera(viewport, offset) {
  if (!viewport || !offset) {
    return;
  }

  if ('eye' in viewport) {
    viewport.eye[0] = (Number(viewport.eye[0]) + offset.x).toString();
    viewport.eye[1] = (Number(viewport.eye[1]) + offset.y).toString();
    viewport.eye[2] = (Number(viewport.eye[2]) + offset.z).toString();
  }

  if ('target' in viewport) {
    viewport.target[0] = (Number(viewport.target[0]) + offset.x).toString();
    viewport.target[1] = (Number(viewport.target[1]) + offset.y).toString();
    viewport.target[2] = (Number(viewport.target[2]) + offset.z).toString();
  }

  if ('pivotPoint' in viewport) {
    viewport.pivotPoint[0] = (Number(viewport.pivotPoint[0]) + offset.x).toString();
    viewport.pivotPoint[1] = (Number(viewport.pivotPoint[1]) + offset.y).toString();
    viewport.pivotPoint[2] = (Number(viewport.pivotPoint[2]) + offset.z).toString();
  }
};

var applyOffsetToCutplanes = function applyOffsetToCutplanes(cutplanes, offset) {
  if (!cutplanes || !offset) {
    return;
  }

  var normal = new THREE.Vector3();

  for (var i = 0; i < cutplanes.length; i++) {
    var cutplane = cutplanes[i];
    // A cutplane is an array of 4 numbers. The first 3 numbers represent the plane's normal vector
    // and the 4th number is the distance along it
    toVector(cutplane, normal);
    // Translating a plane by an offset vector is equivalent to adding dot(n,of) where n is the plane normal
    // This again is equivalent to adding or subtracting dot(n, of) to the constant of the plane
    // We have plane.constant = -plane.normal.dot(onPlane + globalOffset)
    //                        = -plane.normal.dot(onPlane) - plane.normal.dot(globalOffset)
    //                        = oldConstant - plane.normal.dot(globalOffset)
    cutplane[3] = Number(cutplane[3]) - normal.dot(offset);
  }
};

var amendViewportIfNeeded = function amendViewportIfNeeded(item, globalOffset) {
  if (globalOffset) {
    var state = JSON.parse(JSON.stringify(item.data.viewerState));
    var invGlobalOffset = { x: -globalOffset.x, y: -globalOffset.y, z: -globalOffset.z };

    applyOffsetToCamera(state.viewport, invGlobalOffset);

    if (item.attributesVersion >= 2) {
      applyOffsetToCutplanes(state.cutplanes, invGlobalOffset);
    }

    return state;
  }

  return item.data.viewerState;
};

var generateMetadata = function generateMetadata(viewerState, globalOffset) {
  var state = JSON.parse(JSON.stringify(viewerState));

  if (globalOffset) {
    applyOffsetToCamera(state.viewport, globalOffset);
    applyOffsetToCutplanes(state.cutplanes, globalOffset);

    state.globalOffset = globalOffset;
  }

  return state;
};

var restoreViewState = function restoreViewState(viewer, item) {
  if (item.data && item.data.viewerState) {
    var model = viewer.model;
    var globalOffset = model ? model.getData().globalOffset : null;

    var amendedData = amendViewportIfNeeded(item, globalOffset);

    viewer.restoreState(amendedData, null, false);

    // RestoreState will async to update camera's all data. Here force update camera before load pushpin.
    var navapi = viewer.navigation;

    if (navapi) {
      navapi.updateCamera();
      var camera = navapi.getCamera();

      camera.updateMatrixWorld();
      camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    }
  }
};

// Convert from array of values (or number-strings) to THREE.Vector.
// Like THREE.Vector3.fromArray(), but with string->number conversion, because some viewerState values are stored as strings.
var toVector = function toVector(src, dst) {
  dst.x = Number(src[0]);
  dst.y = Number(src[1]);
  dst.z = Number(src[2]);
};

// Transforms a point given as array-3 by a THREE.Matrix4
var transformPoint = function () {
  var v = new THREE.Vector3();

  return function (values, tf) {
    toVector(values, v);
    v.applyMatrix4(tf);
    v.toArray(values);
  };
}();

// Transforms a direction vector given as array-3 by a THREE.Matrix4
var transformNormal = function () {
  var v = new THREE.Vector3();
  var normalMatrix = new THREE.Matrix3();

  return function (values, tf) {
    toVector(values, v);

    normalMatrix.getNormalMatrix(tf);
    v.applyMatrix3(normalMatrix);
    v.normalize(); // Re-normalize, so that scaling doesn't kill normalized directions.

    v.toArray(values);
  };
}();

var transformViewerState = function transformViewerState(state, tf) {

  // Note that these values are not vectors, but arrays (in some cases even containing string-type-values). 
  transformPoint(state.viewport.eye, tf);
  transformPoint(state.viewport.target, tf);
  transformPoint(state.viewport.pivotPoint, tf);

  transformNormal(state.viewport.up, tf); // may become relevant if tf contains a true-north rotation and the camera-up is not vertical
  transformNormal(state.viewport.worldUpVector, tf);

  if (state.cutplanes) {
    var plane = new THREE.Plane();
    var normal = new THREE.Vector3();

    for (var i = 0; i < state.cutplanes.length; i++) {
      var cutplane = state.cutplanes[i];

      toVector(cutplane, normal);
      var constant = Number(cutplane[3]);
      plane.set(normal, constant);

      plane.applyMatrix4(tf);

      plane.normal.toArray(cutplane);
      cutplane[3] = plane.constant;
    }
  }
};

/***/ }),

/***/ "./extensions/Pushpins/PushPins3D/RenderHandler3D.js":
/*!***********************************************************!*\
  !*** ./extensions/Pushpins/PushPins3D/RenderHandler3D.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderHandler3D; });
/* harmony import */ var _PushPins3D_PushPinBillboardTool3D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PushPins3D/PushPinBillboardTool3D */ "./extensions/Pushpins/PushPins3D/PushPinBillboardTool3D.js");
/* harmony import */ var _PushPinInputHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../PushPinInputHandler */ "./extensions/Pushpins/PushPinInputHandler.js");
/* harmony import */ var _PushPinEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../PushPinEvents */ "./extensions/Pushpins/PushPinEvents.js");
/* harmony import */ var _PushPins3D_PushPinViewerState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../PushPins3D/PushPinViewerState */ "./extensions/Pushpins/PushPins3D/PushPinViewerState.js");
/* harmony import */ var _PushPinConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../PushPinConstants */ "./extensions/Pushpins/PushPinConstants.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var

RenderHandler3D = /*#__PURE__*/function () {
  function RenderHandler3D(viewerApi, pushPinManager) {var _this = this;_classCallCheck(this, RenderHandler3D);
    this.viewer = viewerApi;
    this.pushPinManager = pushPinManager;
    this.pushpinDirty = false;
    this.selectedItem = null;

    this.onExplodeBind = function (e) {return _this.onExplode(e);};
    this.onSectionBind = function (e) {return _this.onSection(e);};

    this.onSelectedChangedBind = function (e) {return _this.onSelectedChanged(e);};
    this.onRemoveBind = function (e) {return _this.onRemove(e);};
    this.onRemoveAllBind = function (e) {return _this.onRemoveAll(e);};
    this.onModifyBind = function (e) {return _this.onModify(e);};
    this.onUpdateBind = function (e) {return _this.onUpdate(e);};
    this.createBind = function (e) {return _this.create(e);};
    this.onVisibilityChangedBind = function (e) {return _this.onVisibilityChanged(e);};
  }_createClass(RenderHandler3D, [{ key: "register", value: function register()

    {
      this.pushpinBillboardTool = new _PushPins3D_PushPinBillboardTool3D__WEBPACK_IMPORTED_MODULE_0__["default"](this.viewer, this.pushPinManager.options);
      this.viewer.toolController.registerTool(this.pushpinBillboardTool);
    } }, { key: "deregister", value: function deregister()

    {
      if (this.pushpinBillboardTool) {
        this.viewer.toolController.deregisterTool(this.pushpinBillboardTool);
        this.pushpinBillboardTool = null;
      }
    } }, { key: "activate", value: function activate()

    {
      if (!this.pushpinBillboardTool.isActive()) {
        this.viewer.toolController.activateTool('pushpinBillboard3D');
      }

      this.inputHandler = new _PushPinInputHandler__WEBPACK_IMPORTED_MODULE_1__["default"](this);

      this.viewer.addEventListener(Autodesk.Viewing.EXPLODE_CHANGE_EVENT, this.onExplodeBind);
      this.viewer.addEventListener(Autodesk.Viewing.CUTPLANES_CHANGE_EVENT, this.onSectionBind);

      this.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_2__["PUSHPIN_EVENTS"].PUSH_PIN_SELECTED_EVENT, this.onSelectedChangedBind);
      this.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_2__["PUSHPIN_EVENTS"].PUSH_PIN_REMOVED_EVENT, this.onRemoveBind);
      this.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_2__["PUSHPIN_EVENTS"].PUSH_PIN_REMOVE_ALL_EVENT, this.onRemoveAllBind);
      this.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_2__["PUSHPIN_EVENTS"].PUSH_PIN_MODIFY_EVENT, this.onModifyBind);
      this.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_2__["PUSHPIN_EVENTS"].PUSH_PIN_UPDATE_EVENT, this.onUpdateBind);
      this.pushPinManager.addEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_2__["PUSHPIN_EVENTS"].PUSH_PIN_VISIBILITY_EVENT, this.onVisibilityChangedBind);
      this.pushPinManager.setCreateFunction(this.createBind);

      return true;
    } }, { key: "deactivate", value: function deactivate()

    {
      if (this.pushpinBillboardTool.isActive()) {
        this.viewer.toolController.deactivateTool('pushpinBillboard3D');
      }

      this.inputHandler.detach();

      this.viewer.removeEventListener(Autodesk.Viewing.EXPLODE_CHANGE_EVENT, this.onExplodeBind);
      this.viewer.removeEventListener(Autodesk.Viewing.CUTPLANES_CHANGE_EVENT, this.onSectionBind);

      this.pushPinManager.removeEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_2__["PUSHPIN_EVENTS"].PUSH_PIN_SELECTED_EVENT, this.onSelectedChangedBind);
      this.pushPinManager.removeEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_2__["PUSHPIN_EVENTS"].PUSH_PIN_REMOVED_EVENT, this.onRemoveBind);
      this.pushPinManager.removeEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_2__["PUSHPIN_EVENTS"].PUSH_PIN_REMOVE_ALL_EVENT, this.onRemoveAllBind);
      this.pushPinManager.removeEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_2__["PUSHPIN_EVENTS"].PUSH_PIN_MODIFY_EVENT, this.onModifyBind);
      this.pushPinManager.removeEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_2__["PUSHPIN_EVENTS"].PUSH_PIN_UPDATE_EVENT, this.onUpdateBind);
      this.pushPinManager.removeEventListener(_PushPinEvents__WEBPACK_IMPORTED_MODULE_2__["PUSHPIN_EVENTS"].PUSH_PIN_VISIBILITY_EVENT, this.onVisibilityChangedBind);
      this.pushPinManager.removeCreateFunction(this.createBind);
    } }, { key: "setPushpinDirty", value: function setPushpinDirty()

    {
      this.pushpinDirty = true;
    } }, { key: "onSelectedChanged", value: function onSelectedChanged(

    event) {
      if (event.value) {
        this.selectedItem = event.value;

        if (!this.selectedItem.marker) {
          this.create(this.selectedItem);
        }

        this.pushpinBillboardTool.selectPushpin(this.selectedItem);
        Object(_PushPins3D_PushPinViewerState__WEBPACK_IMPORTED_MODULE_3__["restoreViewState"])(this.viewer, this.selectedItem);

        if (this.selectedItem.draggable) {
          this.enableItemDragging(this.selectedItem);
        }

        this.viewer.dispatchEvent({ type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_2__["PUSHPIN_EVENTS"].PUSH_PIN_SELECTED_EVENT });
      } else {
        this.deselectItem();
        this.pushpinBillboardTool.deselect();

        var sectionExt = this.viewer.getExtension('Autodesk.Section');

        if (sectionExt && sectionExt.getSectionPlanes().length === 1) {
          sectionExt.setSectionFromPlane(null);
        } else {
          this.viewer.impl.setCutPlaneSet('__set_view', undefined);
        }
      }

      this.setPushpinDirty();
    } }, { key: "deselectItem", value: function deselectItem()

    {
      this.selectedItem = null;
      this.inputHandler.detach();
    } }, { key: "onRemove", value: function onRemove(

    event) {
      if (this.selectedItem && event.value.data.id === this.selectedItem.data.id) {
        this.deselectItem();
      }

      if (event.value && event.value.marker) {
        this.pushpinBillboardTool.removePushpin(event.value);
      }
    } }, { key: "onRemoveAll", value: function onRemoveAll()

    {
      this.deselectItem();
      this.pushpinBillboardTool.removeAll();
    } }, { key: "onModify", value: function onModify()

    {
      this.pushpinDirty = true;
    } }, { key: "onVisibilityChanged", value: function onVisibilityChanged()

    {
      this.pushpinBillboardTool.showMarkers();
    } }, { key: "onUpdate", value: function onUpdate()

    {var _this2 = this;
      setTimeout(function () {
        _this2.setPushpinDirty();

        // it could happen that the extension was removed in the meantime
        _this2.pushpinBillboardTool && _this2.pushpinBillboardTool.setDirty();
        var selectedItem = _this2.pushPinManager ? _this2.pushPinManager.getSelectedItem() : null;

        if (!selectedItem) {
          return;
        }

        selectedItem.draggable && selectedItem.marker ?
        _this2.enableItemDragging(selectedItem) :
        _this2.disableItemDragging(selectedItem);
      }, 1);
    } }, { key: "enableItemDragging", value: function enableItemDragging(

    item) {
      this.pushpinBillboardTool.enableDragging(item);
      this.inputHandler.attachTo(item.marker);
    } }, { key: "disableItemDragging", value: function disableItemDragging(

    item) {
      this.pushpinBillboardTool.disableDragging(item);
      this.inputHandler.detach();
    } }, { key: "onExplode", value: function onExplode(

    e) {
      if (e.scale * 1.0 === 0) {
        this.pushpinBillboardTool.showMarkers();
      } else {
        this.pushpinBillboardTool.hideMarkers();
      }
    } }, { key: "onSection", value: function onSection()

    {
    } }, { key: "create", value: function create(

    item) {
      // iOS have a special case where they already have the UUID, so we act like we are re-selecting an existing item
      return this.createRenderItem(item, Autodesk.Viewing.isIOSDevice());
    } }, { key: "createRenderItem", value: function createRenderItem(

    item, reselect) {
      // Make sure it's a uuid and not a growing counter
      var isLoaded = item.data.id.length > 20;

      this.pushpinBillboardTool.deselect();

      var promise;
      if (isLoaded && !reselect) {
        promise = this.pushpinBillboardTool.loadPushpin(item);
      } else {
        promise = this.pushpinBillboardTool.createPushpin(item);
        this.pushPinManager.selectOne(item.data.id);
      }

      return promise;
    } }, { key: "updatePattern", value: function updatePattern(

    status, size, hex) {
      this.pushpinBillboardTool.updateStyle(status, size, hex);

      this.setPushpinDirty();
    } }, { key: "render", value: function render()

    {var _this3 = this;
      if (!this.pushPinManager || !this.viewer.model) {
        return;
      }

      this.pushPinManager.items().reverse().forEach(function (item) {
        if (!item.marker) {
          _this3.createRenderItem(item, false);
        }
      });

      if (this.pushpinDirty) {
        this.pushpinBillboardTool.updatePushpins();
        this.pushpinDirty = false;
      }
    } }, { key: "findIntersections", value: function findIntersections(

    event) {
      var mouseX = event.clientX;
      var mouseY = event.clientY;

      var hitItem = null;

      this.pushPinManager.items().some(function (item) {
        if (item.selectable && item.marker) {
          var bb = item.marker.getBoundingClientRect();
          if (mouseX > bb.left && mouseX < bb.left + bb.width && mouseY > bb.top && mouseY < bb.top + bb.height) {
            hitItem = item;
            return true;
          }
        }
        return false;
      });

      return hitItem;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    e) {
      function mouseCoords(ev) {
        if (ev.pageX || ev.pageY) {
          return { x: ev.pageX, y: ev.pageY };
        }

        return {
          x: ev.clientX + document.body.scrollLeft - document.body.clientLeft,
          y: ev.clientY + document.body.scrollTop - document.body.clientTop };

      }

      if (this.selectedItem.marker.startDragging) {
        // only on first mouse movement
        if (!this.newX) {
          this.selectedItem.marker.style.transform = 'translate(0px, 0px)';
        }

        var mousePos = mouseCoords(e);

        this.newX = mousePos.x - this.mouseOffset.x;
        this.newY = mousePos.y - this.mouseOffset.y;

        // Check left, top, right, bottom
        var containerBounds = this.viewer.navigation.getScreenViewport();
        var wi = this.selectedItem.marker.clientWidth;
        var hi = this.selectedItem.marker.clientHeight;

        if (this.newX < 5) {
          this.newX = 0;
        }
        if (this.newY < 5) {
          this.newY = 0;
        }
        if (containerBounds.width - 5 < this.newX + wi) {
          this.newX = containerBounds.width - wi;
        }
        if (containerBounds.height - 5 < this.newY + hi) {
          this.newY = containerBounds.height - hi;
        }

        this.selectedItem.marker.style.left = "".concat(this.newX, "px");
        this.selectedItem.marker.style.top = "".concat(this.newY, "px");

        var vpVec = this.viewer.impl.clientToViewport(this.newX + this.offsetWidth / 2, this.newY + this.offsetWidth / 2);
        var res = this.viewer.impl.castRayViewport(vpVec, false);

        !res ? this.selectedItem.marker.classList.add('grey-out') : this.selectedItem.marker.classList.remove('grey-out');

        this.selectedItem.marker.dragging = true;
      }
    } }, { key: "handleMouseUp", value: function handleMouseUp(

    e) {var _this4 = this;
      if (this.selectedItem.marker.dragging) {
        this.selectedItem.marker.style.left = '0px';
        this.selectedItem.marker.style.top = '0px';
        this.selectedItem.marker.style.transform = "translate(".concat(this.newX, "px, ").concat(this.newY, "px)");

        this.newX += this.offsetWidth / 2;
        this.newY += this.offsetWidth / 2;

        var result = this.viewer.impl.clientToWorld(this.newX, this.newY);

        if (result) {
          this.selectedItem.data.position = { x: result.point.x, y: result.point.y, z: result.point.z };
        }

        this.pushpinBillboardTool.removePushpin(this.selectedItem);
        var promise = this.createRenderItem(this.selectedItem, true);

        if (result) {
          promise.then(function () {return _this4.pushPinManager.generateThumbnail(_this4.selectedItem);}).
          then(function (thumbnail) {
            _this4.pushPinManager.fireEvent({ type: _PushPinEvents__WEBPACK_IMPORTED_MODULE_2__["PUSHPIN_EVENTS"].PUSH_PIN_MODIFY_EVENT, value: _this4.selectedItem, thumbnail: thumbnail });
          });
        }

        this.selectedItem.marker.startDragging = false;
        this.selectedItem.marker.dragging = false;

        this.onUpdate();
      } else {
        this.selectedItem.marker.startDragging = false;
      }
    } }, { key: "handleMouseDown", value: function handleMouseDown(

    event) {
      function getPosition(e) {
        var left = 0;
        var top = 0;

        while (e.offsetParent) {
          left += e.offsetLeft;
          top += e.offsetTop;
          e = e.offsetParent;
        }

        left += e.offsetLeft;
        top += e.offsetTop;
        return { x: left, y: top };
      }

      function getMouseOffset(target, offsetWidth) {
        var docPos = getPosition(target);

        docPos.x += offsetWidth / 2;
        docPos.y += offsetWidth / 2;
        return { x: docPos.x, y: docPos.y };
      }

      if (event.target.tagName.toLowerCase() === 'textarea') {
        return;
      }

      this.offsetWidth = this.selectedItem.selected ? _PushPinConstants__WEBPACK_IMPORTED_MODULE_4__["markerOffsets"].selectedMarkerOffsetWidth : _PushPinConstants__WEBPACK_IMPORTED_MODULE_4__["markerOffsets"].markerOffsetWidth;

      this.mouseOffset = getMouseOffset(this.viewer.container, this.offsetWidth);

      this.selectedItem.marker.style.opacity = '1.0';

      this.newX = null;
      this.newY = null;

      this.selectedItem.marker.startDragging = true;
    } }]);return RenderHandler3D;}();

/***/ }),

/***/ "./node_modules/css-loader/index.js!./extensions/Pushpins/PushPinExtension.css":
/*!****************************************************************************!*\
  !*** ./node_modules/css-loader!./extensions/Pushpins/PushPinExtension.css ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/*<editor-fold desc=\"ISSUES\">*/\n@font-face {\n    font-family: 'issueicon';\n    src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAbIAAsAAAAABnwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIFlWNtYXAAAAFoAAAAVAAAAFQXQdKyZ2FzcAAAAbwAAAAIAAAACAAAABBnbHlmAAABxAAAAqAAAAKgxE+X+WhlYWQAAARkAAAANgAAADYKqzOVaGhlYQAABJwAAAAkAAAAJAfCA8dobXR4AAAEwAAAABgAAAAYDgAAAGxvY2EAAATYAAAADgAAAA4BeADcbWF4cAAABOgAAAAgAAAAIAAPAIBuYW1lAAAFCAAAAZ4AAAGeHnABF3Bvc3QAAAaoAAAAIAAAACAAAwAAAAMDVQGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA6RYDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADgAAAAKAAgAAgACAAEAIOkW//3//wAAAAAAIOkV//3//wAB/+MW7wADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAACAAA//cEAAN3AAsAHgAyAE4AZABqAHQAfQAAASYiBwMGFjMhMjYnJzAiIyoBMTA0NTwBMTAyMzoBMTUwIiMqATEwND0BPAExMDIzOgExEyYiDwEuASMiDgIHMR4BFwcGFBcWMjcBNjQnASoBIyIGFRwBFQcuATU0PgIzMhYXAx4BMzcHJTEuAScHEz4BNwUHHgEXNy4BJwLeChcK1QoMEwGrEA8KxBYQEBcXEBAWFhAQFxcQEBavDSINxCdNKlaehWcgHV05lQ0NDSINA0QNDf5vAwcDOlM3BwYhOEoqECMNZwoPCTxeAisgaUBIqyAzE/2mXRMrFzwQGgoBohAQ/poQFxcQBBENDREmGxA3ExgCSA0NxAoQMlRyQDlqKZYNIg0MDANFDSIM/qtTOgMGAzgQIBArSzcgBwb+wAMBZmKEQHAqSf7jIEYmt14GDANiAwcHAAcAAAAVBAACzQAKABUAGgA0AEAAUwBnAAABIgYVFBYXNy4BIwchHgMXNy4BNSEjFz4BJzMuAyMiDgIHITQ+AjMyFhc3NjIfAScmIgcDBhYzITI2JycwIiMqATEwNDU8ATEwMjM6ATE1MCIjKgExMDQ9ATwBMTAyMzoBMQIAOlNPOnsTPibN/s0bU2p9RTtGXALNwFUkNKm8IGeFnlZWnoVnIAEzIThKKjBRHQgNLw1VZgoXCtUKDBMBqxAPCsQWEBAXFxAQFhYQEBcXEBAWAiJTOjlQA9UdJ402Y1A5DWMQc0mRI0gmQHJUMjJUckAsSjgfKCAMFxeRDRAQ/poQFxcQCBENDREiGxA3ExgAAAAAAQAAAAEAAOgguddfDzz1AAsEAAAAAADTxfeVAAAAANPF95UAAP/3BAADdwAAAAgAAgAAAAAAAAABAAADwP/AAAAEAAAAAAAEAAABAAAAAAAAAAAAAAAAAAAABgQAAAAAAAAAAAAAAAIAAAAEAAAABAAAAAAAAAAACgAUAB4AyAFQAAAAAQAAAAYAfgAIAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAkAAAABAAAAAAACAAcAcgABAAAAAAADAAkAPAABAAAAAAAEAAkAhwABAAAAAAAFAAsAGwABAAAAAAAGAAkAVwABAAAAAAAKABoAogADAAEECQABABIACQADAAEECQACAA4AeQADAAEECQADABIARQADAAEECQAEABIAkAADAAEECQAFABYAJgADAAEECQAGABIAYAADAAEECQAKADQAvGlzc3VlaWNvbgBpAHMAcwB1AGUAaQBjAG8AblZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGlzc3VlaWNvbgBpAHMAcwB1AGUAaQBjAG8Abmlzc3VlaWNvbgBpAHMAcwB1AGUAaQBjAG8AblJlZ3VsYXIAUgBlAGcAdQBsAGEAcmlzc3VlaWNvbgBpAHMAcwB1AGUAaQBjAG8AbkZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=);\n    font-weight: normal;\n    font-style: normal;\n}\n\n[class^=\"issueicon-\"], [class*=\" issueicon-\"] {\n    font-family: 'issueicon';\n    font-style: normal;\n    font-weight: normal;\n    font-variant: normal;\n    line-height: 1;\n    padding-top: 2px;\n    speak: none;\n    text-transform: none;\n\n\n    /* Better Font Rendering =========== */\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n}\n\n@font-face {\n    font-family: 'rfiicon';\n    src: url(data:application/font-woff;charset=utf-8;base64,d09GRk9UVE8AAAswAAsAAAAAEmAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABDRkYgAAABCAAACA8AAA2TY1sJ2EZGVE0AAAkYAAAAGgAAABx62YowR0RFRgAACTQAAAAbAAAAHgAnAAtPUy8yAAAJUAAAAEsAAABgVnlR5GNtYXAAAAmcAAAAQAAAAVIAM+PPaGVhZAAACdwAAAAwAAAANgwjbUZoaGVhAAAKDAAAAB0AAAAkB5sEBGhtdHgAAAosAAAAEAAAABAKKACSbWF4cAAACjwAAAAGAAAABgAFUABuYW1lAAAKRAAAAOAAAAGJyIp2aHBvc3QAAAskAAAADAAAACAAAwAAeJzNV3lQVdcZP+/xNh/wlOUBEsqiIxa1SbMAEg0YoKgRl6QUlWHcAiqWQINLJmEsMWIiuaYxBRNBQFCSWGiVqJOKIMuo2BYtcaImyGhiG3DEhYgo+/v6++6976kzOplO/+mb4czvnvPdb/9+56IROp3QaDSmrJVpaa9mZgiNVmhEZL+/tj/Aqd9HJ7k4SS46f7MYtSHxKUlyABfjoW2DOQPX9H6iYrSfEGP8xF/c/ISrn2ucu9CzDosIFM+ICDFjNtSuXfpK3Gz+u//w69WZbzy8MystJZWB6ordI/w0mvc0WzV5imKt0GkHDLddJMs9C2lyP8DSlJtkJchFG0kY3NJIaL10JHSfLiPhVLQEyzsuJPT+R4DSahnVkNActkE4K0MiYdxvxWoqO0E0UrMIu9dPEQ1JMZCcnwyU1cPoCaKBY71Q8XIlUd+3+VCRbsLpjZdg+iPs3TlxCWjWYaLrJa9LOPq2YRpRg+sCEhMmNRlI+FijYGe0x3q86qyFzgEv2VUTaYN/dojE37YelsPQkAjJhLnLwZ+TCGpbRHThT1OhcOTF8QkGPGzvIOV3OXifvEjypolsEDCqZxe2d6ovsxQrhAZt/YkkAz/48tliRYAfA8gW6oOQlr611Ep0vEULle0HSkmEN0brEdoT40l4XAtH4E9+QsJl8zcIPHoeQgh3tiOklwYHCpWU02B1BaLsWOZAy/Huh1AoeqqJejPaOEF3L14h2vHCU0RnGjb2FZBI+yoI7vlue0lNg8fCVtSkfBZMmnO4ErcZNQEllZEYVdWsVsL43DEojQwDmmthFKq60VOeh0h+PJeN9UbjSXjzdjSeJ0HZXQF0J/sqoxdV1L3zPFH/qKlEXU+vJhpuRubMV6eg8uuj0CHXjuK0JRZW/NYARRSaGP6WYRHcyU6BwZ8/rTp7w+vvOP5h9WES/zStRYfRuaotRO/t95SAj6cdJbGqq0my7+9EcwDnR02TsyFJfQV60uiOHZRTYR0qUJNkRL/bfMtIO6myycqFrkfGZqYuUzMWcSGOqLk2BapqYouR43Nj29EzZ92CFQFqKyzipVDizYkQOP+bKPTMkaLdqkBzCEYkInYXWjWuNtXEawrr/RXvFrOt5f44q1z+D8W8vOhJfB3che1Dl1DNN6cAzXt5IlHy65UwoW0UcHL9xXKi3X+s5i7bTZTnu0RdeI/Ktuwhen9CAHTT+xmeELrTj90SzMWG4luwUToATZWVTXB2SuMJSMWPO0viXZ7VL05NJrH3D4kwOvU80Gf7FEdw2gzHoqaj2UTLL4PIFnwgGV7bXk1AW/1ur9JbZHumB7XuiwfqtT2I+t+ZB8MZieiOu5u4YW+uySERuAXJ9ijbjJDMEwKUaRMGZI2oNRmtPnIQ6K/xICCPL4ESQUVOgWg92xx0jjYOIzuy6BWgJxNVpBkPd4Y33kFMQ7WfYR0OnYEXJ5QrHYgXnWR3EUTnypUkctcdA094VkHdmH40bLcxHZyTkA1fAksO2gngekIdH73Gy2T5HBHYykoOGpQzpdp8Bi35EivcAgvfrZhnVHvJsypGPlPM8DnncVNuEtGkykaFcfGevyVRmTEwXHcp2GLQcA3T0JuNcEKGkZobJg6PqfPfHnKgjNx5nL+ws8VOGHGKABeZ0VBCU/xnTNvE17A3lApqycGeIZo5PKdBRWgpzF6fGfZH5a9nEv9Yp1RSGGrHw0pqOcSvINbhuSBg/fcnVZ7SeaCtBm7t5FKsNDH8RIZE9xKeV2vRU9PO1W7xbh1CI441/kgi9M12meNQdH31CtjTxfogye+i07Sf7wdync/oAKPRQB8mszegK+2SI1y8igeRbh2aa6A+lC+gTBh2jkVe8xd+gP7dlGcNNIMIIzeAGUufs/Z5EnV+Vz/kyXM/n2+iyuPu6uBx/qEMFMGJRuJHzlaqBDtSU2RH6h7iSdmEdKQULoJk99snVbbriHGX+Hkzqrxqsknpd77Q9IqAGJMzHeH61t2UBfh5I7zdCi4UeZoWSFU5nyIRlltCVJe6h0R8hz/RN7uukkh461+Pn0gSMS1aHhncCTFgfYU5I3ky4RIs7OLrZ9fvB/Vscppq3LfuliS7IDtnUm9euKxXBDgwSdaghofAcHFuG/cV2XaPXawkToI1unob1NfZBbIuDsFt2Ybyem/eQXTJKQFqI+do5QXh9b0xh4RbFi6Bob07MPiWNnjgkfm95GDGODszzrXw0cTJWN0vh+GFr/vw6uJ2vqUKWCtIRUS5LtCzGejy2ncXqRq3Xb3ULszsZsf2mx7FiwGktX65lURN8k1M3oyLOD/dEUDiWSbcBu7DoGWC6Gh4vINwhY8bgvrhsvqR4n16Nl9u4bC7vRNUULEgiJcVfDXJ7TRn1lp5QS69vMGB/UWon7f5BZ4hdLf381fs7ik03Jocgldbt53hCxhkczbrFyQsprUm0iSdn4HrbbG38j0jqSOtTIVCvhUP0/DM/18a3uOgYa3s+H0arrM6SJJbLQBdeX36GgcNqwycfp+B/R8kYOWnEnDBf03ATQ8RsF59RSb1e2c+QiGGxjEVd6lU/FOk3Osg5epHkHKDg5TTHaTc4CDl+odJ2Vkm5XWPIuU9Mimb1I56DCs7SHnV/0LKMhUvcNCzxUHKPQ4q3vsIUg5zkHLMY0g51Crh60zhZUka8tRbBgs8+0OskosZ/wF58L9T05WRgkfW0lB5XFgQXgdG4yNPhKVjeRa9bBc4bc5h7L8wXu/8Hx99d3AAeJxjYGBgZACCi88SbUH0lcoplTAaAEwCBwsAAHicY2BkYGDgAWIxIGZiYARCFjAG8RgAA8oAMwB4nGNgZp7JOIGBlYGDaSbTGQYGhn4IzfiawZiRk4GBiYGVmQEGGAUYECAgzTWFwYFB4QEz84H/BxhimEP+/wepgStQAEJGAKiDDfoAeJxjYGBgZoBgGQZGBhDwAfIYwXwWBgMgzQGETGAZhQfM//9DWYwg1v+HCoxQXWDAyMaAzMUKCMkPdQAA6jkI4XicY2BkYGAAYiWvHx7x/DZfGbhZGEDgSuWUKjitwcDI/Io5BMjlYGACiQIAFHsJinicY2BkYGAOYWBgiGFhAAHmVwyMDKiAGQAmnQGqAAAABAAAAAIAAAAEAABVACgAPQAAUAAABQAAeJx1jj1uwjAYhp9AoEKtqk5VRw8MXRLFHhg4QNSZgR0hE0VCRDKwcJCuPULHHqMH6BF6ib4J39IBW/78+PX7/QAPvJPRr4w7noxH4lfjMXMuxrn0T+MJ93wbT6X/ypnlMymPQ1bPI/GL8Zg3KuNc+ofxhGe+jKfSf0jsaLW3dBwg7dp22wlWRBrO7NnIwyo25/1GUA++03AnOSKOQKlujqXO/3pXzbOgUAyKQc7+Td0dTnWXmuhCWbmls84ivyh8KELl5bo13lqNE0f9XNv4YQTWMR1bFfFldTP3D4aYOgJ4nGNgZsALAAB9AAQ=);\n    font-weight: normal;\n    font-style: normal;\n}\n\n[class^=\"rfiicon-\"], [class*=\" rfiicon-\"] {\n    font-family: 'rfiicon';\n    font-style: normal;\n    font-weight: normal;\n    font-variant: normal;\n    line-height: 1;\n    padding-top: 2px;\n    speak: none;\n    text-transform: none;\n\n\n    /* Better Font Rendering =========== */\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n}\n\n@font-face {\n    font-family: 'fieldissueicon';\n    src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUAAA0AAAAAByQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAE5AAAABwAAAAcfzoDmUdERUYAAATIAAAAGwAAAB4AJwALT1MvMgAAAZwAAABKAAAAYC+xTDxjbWFwAAAB+AAAAEQAAAFKwBQjvWdhc3AAAATAAAAACAAAAAj//wADZ2x5ZgAAAkgAAAFeAAABhPocpV5oZWFkAAABMAAAADAAAAA2DEAuiWhoZWEAAAFgAAAAHAAAACQEIwIFaG10eAAAAegAAAAQAAAAEgYAAABsb2NhAAACPAAAAAwAAAAMAFgAwm1heHAAAAF8AAAAHgAAACAATgBKbmFtZQAAA6gAAADjAAAB47FU88Bwb3N0AAAEjAAAADIAAABR2shGr3icY2BkYGAA4uk3ErPi+W2+MnAzMYDAVZ+8TjB9te4fkGJnYmAE0RwMYGkALxEKOXicY2BkYGD8wsDAoMfEAAJAkpEBFbAAACM+AS54nGNgZGBgYGVwZ2BnAAEmIGZkAIk5gPkMAApQAJkAAHicY2BmYmCcwMDKwMHow5jGwMDgDqW/MkgytDAwMDGwcjLAgQCCyRCQ5prC4PCA8QET44P/Dxj0GL/8/wIUZkRSosDACAAr1Q1fAAB4nGNigAAmKGZgAAAAVgAHeJzdisEJwDAQw+RLyRR59NlBuv8M2STxpaWQFSowRiCg8Kwhktum5QeXv/pFQI8xMujKP+PtjSqfyGXWG+L3TGW0BrEAAAAAAAAAAABYAMJ4nG2PvU7CUBiGv4+fcyhwSiH0HAg/ASptKLQ1LaVoDTHGOOjohAnizwW46AU4GBNnZx2dZfQKSJzYvQYHE1fi0dnhXZ68w/NAGgBoAvAWmmDDCLZhAhC5SSua0MAXhtlHF40O0ctchC6Gw5GkhBrC53qgG2EggdCDkMp9j+db7RSheV20Nmy/9nRRV6unuaDdiwOz0rLqdkml/kJhfCGYwh3HOUuYoVvMKKxS4kU1c8eb3bhnjdOdVLdas7okL3/LpcIG0+mV48Cvq1wev3ANJWhDD3zpuwcHAGgW0JSilAtKBPcjHKX/ZKmEDaRDUxgdK+IxRjIj4sI06D8N+K5q56PK8UO7GR8WCqRI8Flbv04GZdYgzX4jcY2e45WrOMfkbtTKcZFllTfBssLzPPzUtEt2sh8PjrQCIfiifvR3aN1ukDqtPmpu7h4JToxN5rHsapVl7mx247o/vPQ77AAAeJyVj8FKw0AURc+0aUAUiht3ltnLhGQgCAXd2U/IFzQtgZJAmv6KOz/IT/ET3HmnPhe6EDrwmDN37rvzBrjhFUdajiXeeEbOs/GcB96MM3k+jBdcu1vjnKV7ktNlV1JW567EM+WXxnMaXowzed6NF9zxaZyzcvec6JnoVAdatgR2DGctUMGpn7rp0G7DbuinIOHX7Y+4MTHtI3sFeSKFxvGsVf8/8u2J1DqliuqreFSs4jfDuG99LEq/9n+GkRLrUIdYVjJf+pFGrpGjOpLLy5PmpWnHYzf0virKizO/AEzyTYUAeJxjYGJABowM6IAVLMrEyMTIzJ+WmZqToptZXFyaqpuZnCeCzM9PSwOK5ecBAP6rDY8AAAAAAAH//wACeJxjYGRgYOABYjEgZmJgBEIWMAbxGAADygAzAAAAAAEAAAAA1BgWEQAAAADVTG6JAAAAANXVfv4=);\n    font-weight: normal;\n    font-style: normal;\n}\n\n[class^=\"fieldissueicon-\"], [class*=\" fieldissueicon-\"] {\n    font-family: 'fieldissueicon';\n    font-style: normal;\n    font-weight: normal;\n    font-variant: normal;\n    line-height: 1;\n    padding-top: 2px;\n    speak: none;\n    text-transform: none;\n\n\n    /* Better Font Rendering =========== */\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n}\n\n.issueicon-issue_hide:before {\n    content: \"\\E915\";\n}\n.issueicon-issue_normal:before {\n    content: \"\\E916\";\n}\n\n.rfiicon-rfi_hide:before {\n    content: \"\\E003\";\n}\n.rfiicon-rfi_normal:before {\n    content: \"\\E002\";\n}\n\n.fieldissueicon-issue_hide:before {\n    content: \"\\E002\";\n}\n.fieldissueicon-issue_normal:before {\n    content: \"\\E001\";\n}\n\n.leaflet-text-label {\n    display: inherit;\n    font-family: 'HelveticaNeue-bold';\n    font-style: normal;\n    font-weight: normal;\n    font-variant: normal;\n    line-height: 0;\n    pointer-events: none;\n    /*margin-top: 40px;\n    margin-left:-20px;*/\n    text-align: center;\n    font-size: 16px;\n    border-radius: .5em;\n    max-width:auto;\n    min-width: 60px; /*real width = width + border*2*/\n    height: 32px;    /*real height = height + border*2*/\n    position:absolute;\n    background-color:rgba(0,0,0,0.7);\n    color: #FFF;\n    border: 2px solid white;\n}\n\n.leaflet-marker-icon.leaflet-pin-icon {\n    width: 40px;\n}\n\n.leaflet-text-label span {\n    display: inline-block;\n    vertical-align: middle;\n    line-height:32px;\n    white-space: pre;\n}\n\n.leaflet-pushpin-hidden {\n    visibility: hidden;\n}\n\n/* disable push pin visible button's border*/\n#toolbar-pushpinVis, #toolbar-pushpinRfisVis, #toolbar-pushpinFieldIssuesVis {\n    border: none;\n}\n/*</editor-fold>*/\n\n/*<editor-fold desc=\"PUSHPIN BILLBOARD (3D)\">*/\n.pushpin-billboard-marker {\n    position: absolute;\n    font-size: 10px;\n    font-weight: bold;\n    width: 22px;\n    height: 22px;\n\n    left: 0;\n    top: 0;\n\n    line-height: 16px;\n    text-align: center;\n    cursor: pointer;\n    pointer-events: none;\n\n    color: rgba(23, 87, 168, 1.0);\n    border: 4px solid rgba(255, 255, 255, 0.95);\n    background: #4675A8 no-repeat center;\n    background-size: 16px;\n    border-radius: 15px;\n\n    opacity: 1;\n    transition: opacity 0.4s;\n    -webkit-transition: opacity 0.4s;\n}\n\n.rfi-billboard-marker {\n    position: absolute;\n    font-size: 10px;\n    font-weight: bold;\n    width: 22px;\n    height: 22px;\n    line-height: 16px;\n    text-align: center;\n    cursor: pointer;\n    pointer-events: none;\n\n    left: 0;\n    top: 0;\n\n    color: rgba(23, 87, 168, 1.0);\n    border: 4px solid rgba(255, 255, 255, 0.95);\n    background: #4675A8 no-repeat center;\n    background-size: 16px;\n    border-radius: 3px;\n\n    opacity: 1;\n    transition: opacity 0.4s;\n    -webkit-transition: opacity 0.4s;\n}\n\n.pushpin-billboard-marker.selected {\n    border: 5px solid rgba(255, 255, 255, 0.95);\n    border-radius: 20px;\n    background-size: 20px;\n    z-index: 1;\n    top: -3px;\n    width: 28px;\n    height: 28px;\n    left: -3px;\n}\n\n\n.rfi-billboard-marker.selected {\n    border: 5px solid rgba(255, 255, 255, 0.95);\n    border-radius: 4px;\n    background-size: 20px;\n    z-index: 1;\n    top: -3px;\n    width: 28px;\n    height: 28px;\n    left: -3px;\n}\n\n.pushpin-billboard-marker.grey-out {\n    background-color: rgb(145, 145, 145) !important;\n    opacity: 0.5 !important;\n    cursor: not-allowed;\n}\n\n.rfi-billboard-marker.grey-out {\n    background-color: rgb(145, 145, 145) !important;\n    opacity: 0.5 !important;\n    cursor: not-allowed;\n}\n\n.pushpin-container {\n    will-change: transform;\n    transform: translateZ(0);\n    left: 0;\n    top: 0;\n    position: absolute;\n}\n/*</editor-fold>*/", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ })

/******/ });
//# sourceMappingURL=Pushpins.js.map
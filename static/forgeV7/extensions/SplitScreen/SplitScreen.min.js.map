{"version":3,"sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/SplitScreen/SplitScreenGroundShadow.js","webpack://Autodesk.Extensions.[name]/./extensions/SplitScreen/SplitScreen.js","webpack://Autodesk.Extensions.[name]/./extensions/SplitScreen/SplitScreenRenderContext.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","RightShadowMaterial","__webpack_exports__","SplitScreenExtension","AutodeskNamespace","viewer","options","Autodesk","Viewing","Extension","this","proto","squish","a","left","right","Math","abs","load","scope","enabled","renderer","impl","context","permissiveFilter","_this","_black","THREE","Color","setRGB","settings","_viewports","set","val","width","canvas","clientWidth","height","clientHeight","glrenderer","targetContext","createForwardFunction","funcName","apply","arguments","applyForwards","renderScenePart","scene","enableViewportOnOffscreenTargets","vpWidth","vpHeight","length","vpVertStart","shouldRenderForViewport","map","vpFilter","modelId","setViewport","isolateSelectionMeshes","overlays","filter","overlay","meshesHidden","children","mesh","Mesh","visible","model","id","push","setMeshesVisible","meshes","renderOverlays","lights","meshesExcluded","overlayTarget","getNamedTarget","needsClear","setClearColor","clearTarget","setSize","w","h","force","setViewports","viewports","slice","fillStart","fill","resize","addViewport","viewport","removeViewport","index","splice","getViewports","getNumberOfViewports","setUserRenderContext","groundShadow","attach","leftShadow","setUserGroundShadow","rightShadow","Private","GroundShadow","getMaterials","addMaterialNonHDR","getDepthMaterial","setColor","getColor","setAlpha","getAlpha","sceneUpdated","detach","removeNonHDRMaterial","createForward","forwards","rendered","renderShadow","camera","target","halfW","patchRayCast","patchCoordinateConversions","getExtension","patchWorldUp","addEventListener","EXTENSION_LOADED_EVENT","onExtensionLoaded","event","extensionId","removeEventListener","collectControlsToHide","onToolbarButtonsUpdated","hideIncompatibleControls","NAVIGATION_MODE_CHANGED_EVENT","handleResize","aspect","VIEWER_RESIZE_EVENT","modelFilterLeft","modelFilterRight","mapCoords","x","y","top","bottom","viewportId","numberOfViewports","hide","controlsToHide","obj","originalValue","control","setDisplay","collectControl","container","style","display","modelTools","measurementToolbarButton","getControl","navTools","castRayViewport","hideAllFilter","Vector3","vpVecIn","ignoreTransparent","dbIds","modelIds","intersections","modelIdsFiltered","modelQueue","getModels","viewportFilter","unpatchRayCast","clientToViewport","screenToViewport","navigation","viewportToScreen","rolloverObjectViewport","clientX","clientY","vpVec","result","vpVecOut","copy","unpatchCoordinateConversions","worldUpTool","toolController","getTool","worldUpHandleMouseMove","handleMouseMove","worldUpHandleButtonDown","handleButtonDown","worldUpHandleButtonUp","handleButtonUp","startingViewportId","originalX","normalizedX","originalY","normalizedY","transform","console","warn","f","unpatchWorldUp","unload","theExtensionManager","registerExtension"],"mappings":"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","file":"SplitScreen/SplitScreen.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 372);\n","'use strict';\n\nvar RightShadowMaterial = \"SplitScreen_RightGroundShadowMaterial\";\n\n// Proxy to manage 2 separate GroundShadows for split screen\nexport function SplitScreenGroundShadow() {\n\n    this.attach = function(viewer) {\n\n        this.renderer = viewer.impl.glrenderer();\n\n        // Reuse existing ground shadow for left screen and create a separate GroundShadow for the right one.\n        this.leftShadow  = viewer.impl.setUserGroundShadow(this);\n        this.rightShadow = new Autodesk.Viewing.Private.GroundShadow(this.renderer);\n\n        // Make sure that override materials get current cutplanes from MaterialManager\n        var materials = viewer.impl.getMaterials();\n        materials.addMaterialNonHDR(RightShadowMaterial, this.rightShadow.getDepthMaterial());\n\n        // Sync right ground-shadow settings with the original one\n        this.rightShadow.enabled = this.leftShadow.enabled;    \n        this.rightShadow.setColor(this.leftShadow.getColor());\n        this.rightShadow.setAlpha(this.leftShadow.getAlpha());\n\n        // force ground shadow update (including transform reset)\n        viewer.impl.sceneUpdated();\n    };\n\n    this.detach = function(viewer) {\n\n        // clean up secondary ground shadow material\n        var materials = viewer.impl.getMaterials();\n        materials.removeNonHDRMaterial(RightShadowMaterial);\n\n        // recover original ground shadow\n        viewer.impl.setUserGroundShadow(this.leftShadow);\n        viewer.impl.sceneUpdated();\n    };\n\n    // Create function that forwards a function call to left/right GroundShadow. Return values are taken\n    // from the right one. (We can use any, because we keep them in sync)\n    this.createForward = function(funcName) {\n        this[funcName] = function() {\n            this.leftShadow[funcName].apply(this.leftShadow, arguments);\n            return this.rightShadow[funcName].apply(this.rightShadow, arguments);\n        }.bind(this);\n    };\n\n    var forwards = [        \n        \"setTransform\",\n        \"setDirty\",\n        \"prepareGroundShadow\",\n        \"getStatus\",\n        \"clear\",\n        \"setColor\",\n        \"setAlpha\"\n    ];\n    for (var i in forwards) {\n        this.createForward(forwards[i]);\n    }\n    \n    Object.defineProperty(this, 'enabled', {\n        get: function() { \n            return this.leftShadow.enabled;\n        },\n        set: function(enabled) { \n            this.leftShadow.enabled  = enabled; \n            this.rightShadow.enabled = enabled;\n        }\n    });\n\n    Object.defineProperty(this, 'rendered', {\n        get: function() { \n            return this.leftShadow.rendered;\n        },\n        set: function(rendered) { \n            this.leftShadow.rendered  = rendered; \n            this.rightShadow.rendered = rendered;\n        }\n    });\n\n    this.renderShadow = function(camera, target) {\n\n        // Note that the camera is already set to half canvas width\n        var halfW  = camera.clientWidth;\n        var height = camera.clientHeight;\n\n        this.renderer.setViewport(0, 0, halfW, height);\n        this.leftShadow.renderShadow(camera, target);\n\n        this.renderer.setViewport(halfW, 0, halfW, height);\n        this.rightShadow.renderShadow(camera, target);        \n    };\n}\n","import { SplitScreenGroundShadow } from './SplitScreenGroundShadow'\nimport { SplitScreenRenderContext } from './SplitScreenRenderContext'\n\n'use strict';\n\nvar namespace = AutodeskNamespace('Autodesk.Extensions.SplitScreen');\nvar myExtensionName = 'Autodesk.SplitScreen';\nvar navToolsExtension = 'Autodesk.DefaultTools.NavTools';\n\n/**\n * Filter function that returns true for models to be rendered on the specified subcanvas.\n * \n * @callback Autodesk.Viewing.Extensions.SplitScreenExtension~modelFilterFunction\n * @param {number} modelId - The id of the model.\n * @returns {bool}\n */\n\n\n/**\n * This extension subdivides the LMV canvas into between 2 and 4 (inclusive) separate subcanvases.\n *\n * The extension id is: `Autodesk.SplitScreen`\n * \n * For each sub-canvas, you can specify a separate model filter function to control in which\n * canvases each model shall appear. The canvases are numbered as follows:\n * 0  1\n * 2  3\n *\n * By default (no modelFilter), all models are rendered to each subcanvas.\n * Overlays are rendered into both canvases (unless selection highlighting proxies - which are associated with models) \n * \n * Limitations: Most core features of LMV keep working (2D/3D render, mouse-over, selection, directional zoom etc.).\n * However, there are currently some known limitations/tradeoffs:\n * - All canvases must use the same camera. Overcoming this requires to introduce a separate scene graph evaluation too.\n * - Subcanvas configuration is currently limited to subcanvases with the same aspect ratio. Extending that will\n *   (among others) require support for separate cameras.\n * - ZoomToolExtension, SectionTool, and Measure tool are disabled SplitScreen (we hide the UI)\n * - GroundShadow is supported, but doesn't apply model filter yet when refreshing the shadow\n * - GroundReflection in SplitScreen is not supported yet.\n * - We currently use only a single background for both. This is hardly noticeable for discreet backgrounds like the AEC default or fixed colors,\n *   but may disturb when using more detailed environments.\n *\n *\n * @example\n *   var options = {\n *       viewports: [\n *           function(id) { return id === 1; },\n *           function(id) { return id !== 1; }\n *       ]\n *   };\n *   viewer.loadExtension('Autodesk.SplitScreen', options);\n *\n * @param {object} [options]\n * @param {Array.<Autodesk.Viewing.Extensions.SplitScreenExtension~modelFilterFunction?>} [options.viewports] - Filter\n * functions that returns true for models to be rendered for the viewport at that index. Falsy values render everything.\n *\n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.SplitScreenExtension\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n * @constructor\n */\nexport function SplitScreenExtension(viewer, options) {\n    Autodesk.Viewing.Extension.call(this, viewer, options);\n    this.options = options || {};\n}\n\nvar proto = SplitScreenExtension.prototype;\n\n\nproto.load = function() {\n    var scope = this;\n    this.enabled = true;\n\n    // Note that we just wrap the RenderContext, but do not reinitialize it. This avoids a couple of issues like...\n    //  1. Wasting some resources by reallocating targets and effects\n    //  2. EdgeMaterial and DepthMaterial would be recreated, so that we would need to register them again at MaterialManager to keep cutplanes working.\n    //  3. We would lose some settings (e.g. edge rendering flag, sao settings etc.)\n    var renderer = this.viewer.impl.renderer();\n    this.context = new SplitScreenRenderContext(renderer, this.viewer);\n    this.viewer.impl.setUserRenderContext(this.context, true);\n\n    // Replace ground shadow by proxy object that manages an additional GroundShadows for right screen\n    this.groundShadow = new SplitScreenGroundShadow();\n    this.groundShadow.attach(this.viewer);\n\n    // Filter viewports\n    this.patchRayCast();\n\n    // Viewport coordinate conversions\n    this.patchCoordinateConversions();\n\n    // Fix world up (roll) tool\n    if (this.viewer.getExtension(navToolsExtension)) {\n        this.patchWorldUp();\n    } else {\n        var onExtensionLoaded = function(event) {\n            if (event.extensionId === navToolsExtension) {\n                scope.patchWorldUp();\n                scope.viewer.removeEventListener(Autodesk.Viewing.EXTENSION_LOADED_EVENT, onExtensionLoaded);\n            }\n        };\n        this.viewer.addEventListener(Autodesk.Viewing.EXTENSION_LOADED_EVENT, onExtensionLoaded);\n    }\n\n    // Remember which tools we have hidden in order to bring them back later\n    // NOTE: This assumes that the tool display state or existence is not changed while SplitScreen is used. Ideally, we should\n    //       avoid this by making them work together.\n    this.collectControlsToHide();\n\n    // On resize or nav-mode changes, GuiViewer.updateButtonToolbar overwrites the display style for some tools, so that we have\n    // to hide them again.\n    this.onToolbarButtonsUpdated = function() {\n        scope.hideIncompatibleControls(true);\n    };\n    this.viewer.addEventListener(Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, this.onToolbarButtonsUpdated);\n\n    // Adjust camera aspect ratio for half screen width (now and on resize)\n    this.handleResize = function() {\n        var w = scope.viewer.canvas.clientWidth;\n        var h = scope.viewer.canvas.clientHeight;\n        \n        var camera = scope.viewer.impl.camera;\n        camera.clientWidth = w;\n        camera.clientHeight = h;\n        camera.aspect = w / h;\n\n        if (scope.enabled) {\n            camera.clientWidth /= 2.0;\n            if (scope.context.getNumberOfViewports() > 2) {\n                camera.clientHeight /= 2.0;\n            } else {\n                camera.aspect /= 2.0;\n            }\n        }\n\n        // Make sure that incompabible\n        scope.onToolbarButtonsUpdated();\n    };\n    this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.handleResize);\n    this.handleResize();\n\n    if (this.options.viewports) {\n        this.context.setViewports(this.options.viewports)\n    } else if (this.options.modelFilterLeft || this.options.modelFilterRight) {\n        this.context.modelFilterLeft  = this.options.modelFilterLeft;\n        this.context.modelFilterRight = this.options.modelFilterRight;\n    }\n\n    return true;\n};\n\n// Maps a value in the range [Left, Right] with midpoint M so that [L, M] => [L, R] and [M, R] => [L, R]\nfunction squish(a, left, right) {\n    var mid = (right + left) / 2;\n    var range = Math.abs(right - left);\n\n    if (Math.abs(a - left) > Math.abs(a - right)) { // closer to right than left\n        // Move to the left\n        a -= (right - left)/2;\n    }\n\n    a = 2 * a - left;\n\n    return a;\n}\n\n/**\n * Maps the given x/y coordinates onto a viewport. x is assumed to be in [left, right]. y is assumed to\n * be in [top, bottom]. Viewports are numbered left to right, top to bottom starting at 0. E.g if there are\n * 2 viewports, 0 is the left one, 1 is the right one. If there are 4, 0 is top left, 1 is top right, 2 is bottom\n * left, 3 is bottom right.\n *\n * Example: top=-1, bottom=1, right=1, left=-1 with 4 viewports\n *     -1\n * -1 --|-- 1\n *      1\n * (-0.5, -0.5) => (0, 0) vpId=0\n * (-0.25, 1) => (0.5, 1) vpId=2\n * (1, 1) => (1, 1) vpId=3\n *\n *\n * @param {Number} x - The x coordinate to map. Should be in the range [left, right]\n * @param {Number} y - The y coordinate to map. Should be in the range [bottom, top]\n * @param {Number} left - The left boundary of the coordinate system\n * @param {Number} right - The right boundary of the coordinate system\n * @param {Number} top - The top boundary of the coordinate system\n * @param {Number} bottom - The bottom boundary of the coordinate system\n *\n * @return {{x: Number, y: Number, viewportId: Number}} - An object with the new x/y coordinates and the viewport number\n */\nproto.mapCoords = function(x, y, left, right, top, bottom) {\n    var viewportId = 0;\n    var numberOfViewports = this.context.getNumberOfViewports();\n\n    // Need to map the x coordinate\n    if (numberOfViewports >= 2) {\n        viewportId = Math.abs(x - left) < Math.abs(x - right) ? 0 : 1;\n        x = squish(x, left, right);\n    }\n\n    // Need to map the y coordinate\n    if (numberOfViewports >= 3) {\n        viewportId += Math.abs(y - top) < Math.abs(y - bottom) ? 0 : 2;\n        y = squish(y, bottom, top);\n    }\n\n    return {x: x, y: y, viewportId: viewportId};\n};\n\n// Set 'display: none' for all incompatible tools or recover initial display value.\nproto.hideIncompatibleControls = function(hide) {\n    for (var i=0; i<this.controlsToHide.length; i++) {\n        var obj = this.controlsToHide[i];\n        var val = (hide ? 'none' : obj.originalValue);\n        obj.control.setDisplay(val);\n    }\n};\n\nproto.collectControl = function(control) {\n    if (control) {\n        this.controlsToHide.push({\n            control: control,\n            originalValue: control.container.style.display\n        });\n    }\n};\n\n// Collect controls that we have to hide because they are not yet compatible with split screen\nproto.collectControlsToHide = function() {\n\n    this.controlsToHide = [];\n\n    // measure\n    var modelTools = this.viewer.modelTools;\n    this.collectControl(modelTools.measurementToolbarButton);\n    \n    // section\n    this.collectControl(modelTools.getControl('toolbar-sectionTool'));\n\n    // zoom\n    this.collectControl(this.viewer.navTools.getControl('toolbar-zoomTools'));\n};\n\n// Wrap raycast, so that it distinguishes between viewports\nproto.patchRayCast = function() {\n    this.castRayViewport = this.viewer.impl.castRayViewport.bind(this.viewer.impl);\n\n    var hideAllFilter = function() { return false; }; // Hide everything\n\n    var scope = this;\n    var vpVecOut = new THREE.Vector3();\n    this.viewer.impl.castRayViewport = function(vpVecIn, ignoreTransparent, dbIds, modelIds, intersections) {\n        // get visible models\n        var mq = scope.viewer.impl.modelQueue();\n        var models = mq.getModels();        \n\n        // Create list of modelIds to be ray-intersected\n        var modelIdsFiltered = models.map(function(model) { return model.id; });\n\n        // Filter based on viewport\n        // vpVecIn has been augmented with the viewport ID by this point so we can tell which viewport the mouse\n        // event originally came from.\n        // viewportFilter isn't guaranteed to be defined. If there are only 3 viewports, mouse events can still be\n        // mapped to where the 4th viewport would be if it existed. In this case we want to hit nothing\n        var viewports = scope.context.getViewports();\n        var viewportFilter = viewports[vpVecIn.viewportId || 0];\n        modelIdsFiltered = modelIdsFiltered.filter(viewportFilter || hideAllFilter);\n\n        return scope.castRayViewport(vpVecIn, ignoreTransparent, dbIds, modelIdsFiltered, intersections);\n    };\n};\n\n// Recover original raycast function\nproto.unpatchRayCast = function() {    \n    this.viewer.impl.castRayViewport = this.castRayViewport;\n};\n\n// Fix coordinate conversions to respect the split viewports\nproto.patchCoordinateConversions = function() {\n    var scope = this;\n\n    this.clientToViewport = this.viewer.impl.clientToViewport.bind(this.viewer.impl);\n    this.screenToViewport = this.viewer.navigation.screenToViewport.bind(this.viewer.navigation);\n    this.viewportToScreen = this.viewer.navigation.viewportToScreen.bind(this.viewer.navigation);\n    this.rolloverObjectViewport = this.viewer.impl.rolloverObjectViewport.bind(this.viewer.impl);\n\n    // Returns vec with x and y in [-1, 1]\n    this.viewer.impl.clientToViewport = function(clientX, clientY) {\n        var vpVec = scope.clientToViewport(clientX, clientY);\n\n        var result = scope.mapCoords(vpVec.x, vpVec.y, -1, 1, 1, -1);\n\n        vpVec.x = result.x;\n        vpVec.y = result.y;\n\n        // Augment with an id for the viewport that was targeted so we can recover it later\n        vpVec.viewportId = result.viewportId\n\n        return vpVec;\n    };\n\n    // Redirect to the correct viewport at tag the vector with the viewportId\n    this.viewer.navigation.screenToViewport = function(x, y) {\n        var result = scope.mapCoords(x, y, 0, 1, 0, 1);\n\n        var vpVec = scope.screenToViewport(result.x, result.y);\n        vpVec.viewportId = result.viewportId;\n\n        return vpVec;\n    };\n\n    // We can't recover the correct viewport so just assume it's from the left viewport\n    this.viewer.navigation.viewportToScreen = function(x, y) {\n        var vpVec = scope.viewportToScreen(x, y);\n\n        // Just convert to the top left viewport since we can't tell which one it's from\n        vpVec.x /= 2.0;\n\n        if (scope.context.getNumberOfViewports() > 2) {\n            vpVec.y /= 2.0;\n        }\n\n        return vpVec;\n    };\n\n    // Rolling over objects actually doesn't need a conversion so we have to undo the conversion that was applied\n    this.viewer.impl.rolloverObjectViewport = function(vpVecIn) {\n        var vpVecOut = new THREE.Vector3();\n\n        // Convert it back\n        vpVecOut.copy(vpVecIn);\n\n        vpVecOut.x += 1.0;\n        vpVecOut.x /= 2.0;\n        vpVecOut.x -= vpVecIn.viewportId % 2 === 0 ? 1.0 : 0.0;\n\n        if (scope.context.getNumberOfViewports() > 2) {\n            vpVecOut.y += 1.0;\n            vpVecOut.y /= 2.0;\n            vpVecOut.y -= vpVecIn.viewportId > 1 ? 1.0 : 0.0;\n        }\n\n        return scope.rolloverObjectViewport(vpVecOut);\n    }\n};\n\nproto.unpatchCoordinateConversions = function() {\n    this.viewer.impl.clientToViewport = this.clientToViewport;\n    this.viewer.navigation.screenToViewport = this.screenToViewport;\n    this.viewer.navigation.viewportToScreen = this.viewportToScreen;\n    this.viewer.impl.rolloverObjectViewport = this.rolloverObjectViewport;\n};\n\n// Fix world up by patching its input handlers\nproto.patchWorldUp = function() {\n    this.worldUpTool = this.viewer.toolController.getTool('worldup');\n    if (!this.worldUpTool) {\n        console.warn('Failed to patch the world up tool');\n        return;\n    }\n    this.worldUpHandleMouseMove = this.worldUpTool.handleMouseMove.bind(this.worldUpTool);\n    this.worldUpHandleButtonDown = this.worldUpTool.handleButtonDown.bind(this.worldUpTool);\n    this.worldUpHandleButtonUp = this.worldUpTool.handleButtonUp.bind(this.worldUpTool);\n\n    var scope = this;\n\n    // The viewport our interaction started in\n    var startingViewportId = null;\n\n    // Transforms the coordinates to the appropriate viewport. Records which viewport the mouse goes down in so we can\n    // reference it when tracking movement and release.\n    this.worldUpTool.handleButtonDown = function(event) {\n        var originalX = event.normalizedX;\n        var originalY = event.normalizedY;\n\n        var result = scope.mapCoords(originalX, originalY, -1, 1, 1, -1);\n\n        event.normalizedX = result.x;\n        event.normalizedY = result.y;\n        startingViewportId = result.viewportId;\n\n        var result = scope.worldUpHandleButtonDown(event);\n\n        // Reverse the transformation so it doesn't affect other tools further down in the stack\n        event.normalizedX = originalX;\n        event.normalizedY = originalY;\n\n        return result;\n    };\n\n    // Returns a mouse handler function that transforms the input coordinates to the starting viewports coordinates.\n    // This prevents the weird snapping when dragging from one viewport to another when using the roll tool\n    function transform(f) {\n        return function(event) {\n            var originalX = event.normalizedX;\n            var originalY = event.normalizedY;\n\n            // Map the coordinates as usual\n            var result = scope.mapCoords(originalX, originalY, -1, 1, 1, -1);\n\n            // Shift result so it's in the starting viewport's coordinates\n            // X\n            // Only need to do something if we've dragged from left to right or right to left.\n            if (startingViewportId % 2 !== result.viewportId % 2) {\n                // Range becomes [-3, 1] or [-1, 3] depending on which viewport is our reference\n                result.x += 2 * (result.viewportId % 2 - startingViewportId % 2);\n            }\n\n            // Y\n            // Only need to do something if we've dragged from top to bottom or bottom to top.\n            if (startingViewportId > 1 !== result.viewportId > 1) {\n                // Range becomes [-3, 1] or [-1, 3] depending on which viewport is our reference\n                result.y += result.viewportId > 1 ? -2 : 2;\n            }\n\n            event.normalizedX = result.x;\n            event.normalizedY = result.y;\n\n            var result = f(event);\n\n            // Reverse the transformation so it doesn't affect other tools further down in the stack\n            event.normalizedX = originalX;\n            event.normalizedY = originalY;\n\n            return result;\n        };\n    };\n    this.worldUpTool.handleMouseMove = transform(this.worldUpHandleMouseMove);\n    this.worldUpTool.handleButtonUp = transform(this.worldUpHandleButtonUp);\n};\n\nproto.unpatchWorldUp = function() {\n    // The patch wasn't necessarily applied so only unpatch if these are defined\n    if (this.worldUpHandleMouseMove) {\n        this.worldUpTool.handleMouseMove = this.worldUpHandleMouseMove;\n        this.worldUpHandleMouseMove = null;\n    }\n\n    if (this.worldUpHandleButtonDown) {\n        this.worldUpTool.handleButtonDown = this.worldUpHandleButtonDown;\n        this.worldUpHandleButtonDown = null;\n    }\n\n    if (this.worldUpHandleButtonUp) {\n        this.worldUpTool.handleButtonUp = this.worldUpHandleButtonUp;\n        this.worldUpHandleButtonUp = null;\n    }\n};\n\n\n// called on first activation of split screen mode\nproto.unload = function() {\n\n    // recover original RenderContext\n    this.viewer.impl.setUserRenderContext(this.context.context, true);\n\n    // recover original GroundShadow\n    this.groundShadow.detach(this.viewer);\n\n    // revert remapping of raycasts and getWorldpoint\n    this.unpatchRayCast();\n    this.unpatchCoordinateConversions();\n    this.unpatchWorldUp();\n\n    // reset camera to full horizontal fov\n    this.enabled = false;\n    this.handleResize();\n    this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.handleResize);\n\n    // recover visibility of incompatible controls\n    this.hideIncompatibleControls(false);\n    this.viewer.removeEventListener(Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, this.onToolbarButtonsUpdated);\n};\n\n// Register the extension with the extension manager.\nAutodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, SplitScreenExtension);\n","'use strict';\n\nexport function SplitScreenRenderContext(context, viewer) {\n\n    var permissiveFilter = function() { return true; };\n    var _this = this;\n    var _black = new THREE.Color().setRGB(0, 0, 0);\n\n    this.context  = context;\n    this.settings = this.context.settings;\n\n    // By default, 2 viewports, no filters (all models on both viewports)\n    this._viewports = [permissiveFilter, permissiveFilter];\n\n    // Backwards compatibility\n    Object.defineProperty(this, 'modelFilterLeft', {\n        enumerable: true,\n        get: function() {\n            return this._viewports[0];\n        },\n        set: function(val) {\n            this._viewports[0] = val || permissiveFilter; // null/undefined used to mean \"show all\"\n        }\n    });\n    Object.defineProperty(this, 'modelFilterRight', {\n        enumerable: true,\n        get: function() {\n            return this._viewports[1];\n        },\n        set: function(val) {\n            this._viewports[1] = val || permissiveFilter; // null/undefined used to mean \"show all\"\n        }\n    });\n\n    this.width  = viewer.impl.canvas.clientWidth;\n    this.height = viewer.impl.canvas.clientHeight;\n\n    this.renderer = viewer.impl.glrenderer();\n\n    // All standard function calls that we don't override are forwarded to this.context\n    function applyForwards(targetContext) {\n\n        function createForwardFunction(funcName) {\n            return function() {\n                // Forward to target context.\n                return targetContext[funcName].apply(targetContext, arguments);\n            };\n        }\n\n        // For any function that we don't explicitly override in prototype, just forward the calls\n        // to both child contexts.\n        for (var key in targetContext) {\n            \n            // Only care for functions\n            var func = targetContext[key];\n            if (typeof func !== 'function') {\n                continue;\n            }\n\n            _this[key] = createForwardFunction(key);\n        }\n    }\n    applyForwards(this.context);\n\n    this.renderScenePart = function (scene) {\n\n        this.renderer.enableViewportOnOffscreenTargets(true);\n\n        var vpWidth = this.width / 2;\n        var vpHeight = _this._viewports.length > 2 ? this.height / 2 : this.height;\n        var vpVertStart = _this._viewports.length > 2 ? vpHeight : 0;\n\n        var shouldRenderForViewport = _this._viewports.map(function(vpFilter) {\n            return vpFilter(scene.modelId);\n        });\n\n        // Left\n        if (shouldRenderForViewport[0]) {\n            this.renderer.setViewport(0, vpVertStart, vpWidth, vpHeight);\n            this.context.renderScenePart.apply(this.context, arguments);\n        }\n\n        // Right\n        if (shouldRenderForViewport[1]) {\n            this.renderer.setViewport(vpWidth, vpVertStart, vpWidth, vpHeight);\n            this.context.renderScenePart.apply(this.context, arguments);\n        }\n\n        // Bottom left\n        if (shouldRenderForViewport[2]) {\n            this.renderer.setViewport(0, 0, vpWidth, vpHeight);\n            this.context.renderScenePart.apply(this.context, arguments);\n        }\n\n        // Bottom right\n        if (shouldRenderForViewport[3]) {\n            this.renderer.setViewport(vpWidth, 0, vpWidth, vpHeight);\n            this.context.renderScenePart.apply(this.context, arguments);\n        }\n\n        this.renderer.setViewport(0, 0, this.width, this.height);\n        this.renderer.enableViewportOnOffscreenTargets(false);\n    };\n\n    // Set all meshes visible that are excluded by the given model filter.\n    // Returns an array of all meshes that were hidden - is used to recover previous visiblity later.\n    this.isolateSelectionMeshes = function(overlays, filter) {\n\n        var overlay = overlays[\"selection\"];\n        var scene   = overlay && overlay.scene;\n        if (!scene) {\n            return [];\n        }\n\n        var meshesHidden = [];\n        for (var i=0; i<scene.children.length; i++) {\n            var mesh = scene.children[i];\n            if (!(mesh instanceof THREE.Mesh) || !mesh.visible) {\n                continue;\n            }\n            \n            // hide mesh if its model is excluded\n            if (filter && mesh.model && !filter(mesh.model.id)) {\n                mesh.visible = false;\n                meshesHidden.push(mesh);\n            }\n        }\n        return meshesHidden;\n    };\n\n    this.setMeshesVisible = function(meshes) {\n        for (var i=0; i<meshes.length; i++) {\n            meshes[i].visible = true;\n        }\n    };\n\n    this.renderOverlays = function(overlays, lights) {\n        var vpWidth = this.width / 2;\n        var vpHeight = _this._viewports.length > 2 ? this.height / 2 : this.height;\n        var vpVertStart = _this._viewports.length > 2 ? vpHeight : 0;\n\n        var overlayTarget = this.context.getNamedTarget('overlay');\n        var needsClear = false;\n        for (var key in overlays) {\n            var p = overlays[key];\n            var s = p.scene;\n            if (s.children.length) {\n                needsClear = true;\n                break;\n            }\n        }\n        if (needsClear) {\n            this.renderer.setClearColor(_black, 0.0);\n            this.renderer.clearTarget(overlayTarget, true, false, false);\n        }\n\n        this.renderer.enableViewportOnOffscreenTargets(true);\n\n        var meshesExcluded;\n\n        // Left\n        meshesExcluded = this.isolateSelectionMeshes(overlays, _this._viewports[0]);\n        this.renderer.setViewport(0, vpVertStart, vpWidth, vpHeight);\n        this.context.renderOverlays(overlays, lights, true);\n        this.setMeshesVisible(meshesExcluded);\n\n        // Right\n        meshesExcluded = this.isolateSelectionMeshes(overlays, _this._viewports[1]);\n        this.renderer.setViewport(vpWidth, vpVertStart, vpWidth, vpHeight);\n        this.context.renderOverlays(overlays, lights, true);\n        this.setMeshesVisible(meshesExcluded);\n\n        // Bottom left\n        if (_this._viewports.length >= 3) {\n            meshesExcluded = this.isolateSelectionMeshes(overlays, _this._viewports[2]);\n            this.renderer.setViewport(0, 0, vpWidth, vpHeight);\n            this.context.renderOverlays(overlays, lights, true);\n            this.setMeshesVisible(meshesExcluded);\n        }\n\n        // Bottom right\n        if (_this._viewports.length >= 4) {\n            meshesExcluded = this.isolateSelectionMeshes(overlays, _this._viewports[3]);\n            this.renderer.setViewport(vpWidth, 0, vpWidth, vpHeight);\n            this.context.renderOverlays(overlays, lights, true);\n            this.setMeshesVisible(meshesExcluded);\n        }\n\n        this.renderer.setViewport(0, 0, this.width, this.height);\n        this.renderer.enableViewportOnOffscreenTargets(false);\n    };\n\n    this.setSize = function(w, h, force) {\n        this.width  = w;\n        this.height = h;\n        this.context.setSize(w, h, force);\n    };\n\n    /**\n     * Sets the viewports and their filters. There can be at most 4 viewports/filters and at least 2.\n     *\n     * @param {Array.<Function?>} viewports - The array of viewport filters. Each entry in the array is a predicate\n     * function on a model ID indicating whether or not that model ID should be rendered in the viewport. Falsy values\n     * in the array are replaced with a function that always returns true.\n     */\n    this.setViewports = function(viewports) {\n        // Maximum 4 viewports, null means permissive filter\n        viewports = viewports.slice(0, 4) // create a shallow copy of at most 4 of the items\n          .map(function(filter) {\n              return filter || permissiveFilter; // Replace any null values with a permissive filter\n          });\n\n        // Minimum of 2 viewports\n        if (viewports.length < 2) {\n            var fillStart = viewports.length;\n            viewports.length = 2;\n            viewports.fill(permissiveFilter, fillStart);\n        }\n\n        this._viewports = viewports;\n\n        // Trigger a resize to recalculate aspect ratio and cause a redraw\n        viewer.resize();\n    };\n\n    /**\n     * Adds a viewport. If there are already 4 viewports then nothing happens.\n     *\n     * @param {Function?} [viewport] - A filter for the viewport. If no filter is provided then all models are displayed\n     */\n    this.addViewport = function(viewport) {\n        viewport = viewport || permissiveFilter;\n\n        if (this._viewports.length < 4) {\n            this._viewports.push(viewport);\n            // Trigger a resize to recalculate aspect ratio and cause a redraw\n            viewer.resize();\n        }\n    };\n\n    /**\n     * Removes a viewport at the specified index. If the index is out of bounds or there are 2 or fewer viewports\n     * then nothing happens.\n     *\n     * @param {Function?} [viewport] - A filter for the viewport. If no filter is provided then all models are displayed\n     */\n    this.removeViewport = function(index) {\n        if (this._viewports.length <= 2 || index >= this._viewports.length || index < 0) {\n            return;\n        }\n\n        this._viewports.splice(index, 1);\n        // Trigger a resize to recalculate aspect ratio and cause a redraw\n        viewer.resize();\n    };\n\n    /**\n     * Returns a shallow copy of the array of viewports\n     *\n     * @return {Array.<Function>} - The array of viewports\n     */\n    this.getViewports = function() {\n        // Shallow copy so we don't have to worry about other parts of the code modifying it and messing with our\n        // assumptions\n        return this._viewports.slice(0);\n    };\n\n    /**\n     * Returns the number of viewports.\n     *\n     * @return {number} - The number of viewports (between 2 and 4 inclusive)\n     */\n    this.getNumberOfViewports = function() {\n        return this._viewports.length;\n    };\n}\n"],"sourceRoot":""}